<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/avl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Crater/index.html">Crater Container Library</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('avl_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">avl.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 A featureful generic avl tree implementation. Useful for storing ordered mappings.</dd></dl>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>

<p class="definition">Definition in file <a class="el" href="avl_8h_source.html">avl.h</a>.</p>
</div>
<p><a href="avl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An avl tree node, also used to store an entire tree by synecdoche.  <a href="structcr8r__avl__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for avl tree.  <a href="structcr8r__avl__ft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad85d46aba1a8b7000eea7538fddf061b"><td class="memItemLeft" align="right" valign="top"><a id="ad85d46aba1a8b7000eea7538fddf061b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ad85d46aba1a8b7000eea7538fddf061b">CR8R_AVL_DATA</a>(T,  n)&#160;&#160;&#160;<a class="el" href="container_8h.html#a200f4c65e946ac05c4f3af2cb4052688">CR8R_FLA_CAST</a>(T, (char*)((<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>*)(n))-&gt;data)</td></tr>
<tr class="memdesc:ad85d46aba1a8b7000eea7538fddf061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data field of an avl node and cast to a given type. <br /></td></tr>
<tr class="separator:ad85d46aba1a8b7000eea7538fddf061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae0a8d8e6399f0eaaaacaf33354ef2709"><td class="memItemLeft" align="right" valign="top"><a id="ae0a8d8e6399f0eaaaacaf33354ef2709"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ae0a8d8e6399f0eaaaacaf33354ef2709">cr8r_map_insert_result</a> { <b>CR8R_AVL_FAILED</b> = 0, 
<b>CR8R_AVL_INSERTED</b> = 1, 
<b>CR8R_AVL_UPDATED</b> = 2
 }</td></tr>
<tr class="memdesc:ae0a8d8e6399f0eaaaacaf33354ef2709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to test map like data structure insertion against where applicable. <br /></td></tr>
<tr class="separator:ae0a8d8e6399f0eaaaacaf33354ef2709"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a6ee6807d2e7c6c19e76690358c3e82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a0a6ee6807d2e7c6c19e76690358c3e82">cr8r_avl_ft_init</a> (<a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *, void *data, uint64_t size, int(*cmp)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *), int(*add)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *, void *), void *(*alloc)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *), void(*free)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *))</td></tr>
<tr class="memdesc:a0a6ee6807d2e7c6c19e76690358c3e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to initialize a <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a>.  <a href="avl_8h.html#a0a6ee6807d2e7c6c19e76690358c3e82">More...</a><br /></td></tr>
<tr class="separator:a0a6ee6807d2e7c6c19e76690358c3e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef37e961bb3fd70a7c0dca8c0b162cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#afef37e961bb3fd70a7c0dca8c0b162cf">cr8r_avl_ft_initsla</a> (<a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *, <a class="el" href="structcr8r__sla.html">cr8r_sla</a> *sla, uint64_t size, uint64_t reserve, int(*cmp)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *), int(*add)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *, void *))</td></tr>
<tr class="memdesc:afef37e961bb3fd70a7c0dca8c0b162cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to initialize a <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> and associated slab allocator.  <a href="avl_8h.html#afef37e961bb3fd70a7c0dca8c0b162cf">More...</a><br /></td></tr>
<tr class="separator:afef37e961bb3fd70a7c0dca8c0b162cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0957ddd9af1e5ccf143d75b9cba08508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a0957ddd9af1e5ccf143d75b9cba08508">cr8r_avl_new</a> (void *key, <a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *left, <a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *right, <a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *parent, char balance, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a0957ddd9af1e5ccf143d75b9cba08508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new avl node and initialize it with given data.  <a href="avl_8h.html#a0957ddd9af1e5ccf143d75b9cba08508">More...</a><br /></td></tr>
<tr class="separator:a0957ddd9af1e5ccf143d75b9cba08508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6b0ce9af0fbac11aabfb72a4fd7e88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a8a6b0ce9af0fbac11aabfb72a4fd7e88">cr8r_avl_insert</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a8a6b0ce9af0fbac11aabfb72a4fd7e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node in an avl tree with a given value.  <a href="avl_8h.html#a8a6b0ce9af0fbac11aabfb72a4fd7e88">More...</a><br /></td></tr>
<tr class="separator:a8a6b0ce9af0fbac11aabfb72a4fd7e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4d1346b8e273264cdb96429f6cc759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a6c4d1346b8e273264cdb96429f6cc759">cr8r_avl_remove</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a6c4d1346b8e273264cdb96429f6cc759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the node in an avl tree with a given value.  <a href="avl_8h.html#a6c4d1346b8e273264cdb96429f6cc759">More...</a><br /></td></tr>
<tr class="separator:a6c4d1346b8e273264cdb96429f6cc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1715ac023962286958c00d73753def60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a1715ac023962286958c00d73753def60">cr8r_avl_insert_update</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a1715ac023962286958c00d73753def60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node in an avl tree or modify an existing one with a given value.  <a href="avl_8h.html#a1715ac023962286958c00d73753def60">More...</a><br /></td></tr>
<tr class="separator:a1715ac023962286958c00d73753def60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865c31955e987179e00b92c131d26335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a865c31955e987179e00b92c131d26335">cr8r_avl_remove_node</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a865c31955e987179e00b92c131d26335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a given node from the tree containing it.  <a href="avl_8h.html#a865c31955e987179e00b92c131d26335">More...</a><br /></td></tr>
<tr class="separator:a865c31955e987179e00b92c131d26335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16a624395fda046ef88933dafdc314c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ac16a624395fda046ef88933dafdc314c">cr8r_avl_attach</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, <a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:ac16a624395fda046ef88933dafdc314c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a given node to an existing tree.  <a href="avl_8h.html#ac16a624395fda046ef88933dafdc314c">More...</a><br /></td></tr>
<tr class="separator:ac16a624395fda046ef88933dafdc314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce7ae4aa9f1ff38a0f098f5dfc5a375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a9ce7ae4aa9f1ff38a0f098f5dfc5a375">cr8r_avl_detach</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a9ce7ae4aa9f1ff38a0f098f5dfc5a375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a given node from the tree containing it but do not free it.  <a href="avl_8h.html#a9ce7ae4aa9f1ff38a0f098f5dfc5a375">More...</a><br /></td></tr>
<tr class="separator:a9ce7ae4aa9f1ff38a0f098f5dfc5a375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f38c789b328479ae69d4cd0e2fb6a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a75f38c789b328479ae69d4cd0e2fb6a1">cr8r_avl_get</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a75f38c789b328479ae69d4cd0e2fb6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node matching a given element in a tree.  <a href="avl_8h.html#a75f38c789b328479ae69d4cd0e2fb6a1">More...</a><br /></td></tr>
<tr class="separator:a75f38c789b328479ae69d4cd0e2fb6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909e9240331a0c26ec30cd039bb39284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a909e9240331a0c26ec30cd039bb39284">cr8r_avl_search</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a909e9240331a0c26ec30cd039bb39284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the deepest node that is a would be ancestor of a given element, a leaf node which is either the lower bound or upper bound of the given key.  <a href="avl_8h.html#a909e9240331a0c26ec30cd039bb39284">More...</a><br /></td></tr>
<tr class="separator:a909e9240331a0c26ec30cd039bb39284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e48b77b0c84dde64dc0d7b3fcbb34fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a7e48b77b0c84dde64dc0d7b3fcbb34fd">cr8r_avl_root</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n)</td></tr>
<tr class="memdesc:a7e48b77b0c84dde64dc0d7b3fcbb34fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the root of the tree containing a given node.  <a href="avl_8h.html#a7e48b77b0c84dde64dc0d7b3fcbb34fd">More...</a><br /></td></tr>
<tr class="separator:a7e48b77b0c84dde64dc0d7b3fcbb34fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebafa6b9b40c87971610e91889b5cdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#aebafa6b9b40c87971610e91889b5cdb5">cr8r_avl_first</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r)</td></tr>
<tr class="memdesc:aebafa6b9b40c87971610e91889b5cdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node in the tree with the lowest key.  <a href="avl_8h.html#aebafa6b9b40c87971610e91889b5cdb5">More...</a><br /></td></tr>
<tr class="separator:aebafa6b9b40c87971610e91889b5cdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4ce6adaedb8065007151720d017a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a8a4ce6adaedb8065007151720d017a37">cr8r_avl_next</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n)</td></tr>
<tr class="memdesc:a8a4ce6adaedb8065007151720d017a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the inorder successor of a node.  <a href="avl_8h.html#a8a4ce6adaedb8065007151720d017a37">More...</a><br /></td></tr>
<tr class="separator:a8a4ce6adaedb8065007151720d017a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4764d903a24c9bd721eb2a85943296ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a4764d903a24c9bd721eb2a85943296ee">cr8r_avl_last</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n)</td></tr>
<tr class="memdesc:a4764d903a24c9bd721eb2a85943296ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node in the tree with the greatest key.  <a href="avl_8h.html#a4764d903a24c9bd721eb2a85943296ee">More...</a><br /></td></tr>
<tr class="separator:a4764d903a24c9bd721eb2a85943296ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc53d6b26505c9659c48bf532da64950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#adc53d6b26505c9659c48bf532da64950">cr8r_avl_prev</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n)</td></tr>
<tr class="memdesc:adc53d6b26505c9659c48bf532da64950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the inorder predecessor of a node.  <a href="avl_8h.html#adc53d6b26505c9659c48bf532da64950">More...</a><br /></td></tr>
<tr class="separator:adc53d6b26505c9659c48bf532da64950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd10ae542ec2a58bfcf1c923a43cb57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#acbd10ae542ec2a58bfcf1c923a43cb57">cr8r_avl_lower_bound</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:acbd10ae542ec2a58bfcf1c923a43cb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the greatest element l in the tree so that l &lt;= key.  <a href="avl_8h.html#acbd10ae542ec2a58bfcf1c923a43cb57">More...</a><br /></td></tr>
<tr class="separator:acbd10ae542ec2a58bfcf1c923a43cb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8c6e573d04691f416c96bbf373d2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#afb8c6e573d04691f416c96bbf373d2e1">cr8r_avl_upper_bound</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, void *key, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:afb8c6e573d04691f416c96bbf373d2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the lowest element u in the tree so that key &lt; u.  <a href="avl_8h.html#afb8c6e573d04691f416c96bbf373d2e1">More...</a><br /></td></tr>
<tr class="separator:afb8c6e573d04691f416c96bbf373d2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed02212808cd23297e192b769986d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#aaed02212808cd23297e192b769986d3c">cr8r_avl_delete</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:aaed02212808cd23297e192b769986d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an entire avl tree, freeing all nodes in the process.  <a href="avl_8h.html#aaed02212808cd23297e192b769986d3c">More...</a><br /></td></tr>
<tr class="separator:aaed02212808cd23297e192b769986d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384f8f81e2022f5443a404b6c3f90ba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a384f8f81e2022f5443a404b6c3f90ba0">cr8r_avl_swap_nodes</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *a, <a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *b, uint64_t size)</td></tr>
<tr class="memdesc:a384f8f81e2022f5443a404b6c3f90ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two nodes in a tree, swapping their contents and then patching up links.  <a href="avl_8h.html#a384f8f81e2022f5443a404b6c3f90ba0">More...</a><br /></td></tr>
<tr class="separator:a384f8f81e2022f5443a404b6c3f90ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167669111edf2a29943c2c40def381ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a167669111edf2a29943c2c40def381ce">cr8r_avl_decrease</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a167669111edf2a29943c2c40def381ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the binary search tree invariant after decreasing the key for a single node.  <a href="avl_8h.html#a167669111edf2a29943c2c40def381ce">More...</a><br /></td></tr>
<tr class="separator:a167669111edf2a29943c2c40def381ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a2cbae3d2e68a6953d15ee382a99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ad30a2cbae3d2e68a6953d15ee382a99c">cr8r_avl_increase</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:ad30a2cbae3d2e68a6953d15ee382a99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the binary search tree invariant after increasing the key for a single node.  <a href="avl_8h.html#ad30a2cbae3d2e68a6953d15ee382a99c">More...</a><br /></td></tr>
<tr class="separator:ad30a2cbae3d2e68a6953d15ee382a99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c254012fdc9159a219b3bb132df912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a96c254012fdc9159a219b3bb132df912">cr8r_avl_first_post</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r)</td></tr>
<tr class="memdesc:a96c254012fdc9159a219b3bb132df912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node in a postorder traversal of the tree.  <a href="avl_8h.html#a96c254012fdc9159a219b3bb132df912">More...</a><br /></td></tr>
<tr class="separator:a96c254012fdc9159a219b3bb132df912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c1f7d2adc02d947e94aff60ca4e2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ac8c1f7d2adc02d947e94aff60ca4e2e2">cr8r_avl_next_post</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *n)</td></tr>
<tr class="memdesc:ac8c1f7d2adc02d947e94aff60ca4e2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the postorder successor of a given node.  <a href="avl_8h.html#ac8c1f7d2adc02d947e94aff60ca4e2e2">More...</a><br /></td></tr>
<tr class="separator:ac8c1f7d2adc02d947e94aff60ca4e2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8d1cd288fdb89241438668af4bb88e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#abf8d1cd288fdb89241438668af4bb88e">cr8r_avl_sift_down</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:abf8d1cd288fdb89241438668af4bb88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treat the avl tree as a max heap and sift down a given node.  <a href="avl_8h.html#abf8d1cd288fdb89241438668af4bb88e">More...</a><br /></td></tr>
<tr class="separator:abf8d1cd288fdb89241438668af4bb88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446d233258677dfa634aeb5b60857f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a446d233258677dfa634aeb5b60857f15">cr8r_avl_heapify</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a446d233258677dfa634aeb5b60857f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the avl tree into a max heap in place.  <a href="avl_8h.html#a446d233258677dfa634aeb5b60857f15">More...</a><br /></td></tr>
<tr class="separator:a446d233258677dfa634aeb5b60857f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b28a2f3ba6dc52f38a5a8bb974f6e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a36b28a2f3ba6dc52f38a5a8bb974f6e2">cr8r_avl_heappop_node</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **r, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a36b28a2f3ba6dc52f38a5a8bb974f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treat the avl tree as a max heap and remove the top element.  <a href="avl_8h.html#a36b28a2f3ba6dc52f38a5a8bb974f6e2">More...</a><br /></td></tr>
<tr class="separator:a36b28a2f3ba6dc52f38a5a8bb974f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbcbe1cb3032c126794fb3fb6f55a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a3cbcbe1cb3032c126794fb3fb6f55a45">cr8r_avl_reorder</a> (<a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *r, <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *)</td></tr>
<tr class="memdesc:a3cbcbe1cb3032c126794fb3fb6f55a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the tree so that it is sorted according to a new ordering function.  <a href="avl_8h.html#a3cbcbe1cb3032c126794fb3fb6f55a45">More...</a><br /></td></tr>
<tr class="separator:a3cbcbe1cb3032c126794fb3fb6f55a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0a6ee6807d2e7c6c19e76690358c3e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6ee6807d2e7c6c19e76690358c3e82">&#9670;&nbsp;</a></span>cr8r_avl_ft_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_avl_ft_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *, void *)&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *)&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *)&#160;</td>
          <td class="paramname"><em>free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to initialize a <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a>. </p>
<p>Using standard structure initializer syntax with designated initializers may be simpler. However, this function provides basic checking (it checks the required functions aren't NULL). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to user defined data to associate with the function table. generally NULL is sufficient. see <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> for a more in-depth explaination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single element in bytes. Note that the size of a node will be offsetof(cr8r_avl_node, data) + size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparison function. should not be NULL. some functions do not require it, but it is required to do anything useful with avl trees. See <a class="el" href="container_8h.html#adb4b61e520c0cee3c3d074635d6cdef4">cr8r_default_cmp</a> for a basic generic implementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>element composition function. can be NULL for all functions besides <a class="el" href="avl_8h.html#a1715ac023962286958c00d73753def60">cr8r_avl_insert_update</a>. called to combine an existing and new element when this function is called and the element to insert is already in the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocate a single node. Using a slab allocator ( <a class="el" href="structcr8r__sla.html">cr8r_sla</a> ) is a good choice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free</td><td>free a single node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if cmp, alloc, or free is NULL) </dd></dl>

</div>
</div>
<a id="afef37e961bb3fd70a7c0dca8c0b162cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef37e961bb3fd70a7c0dca8c0b162cf">&#9670;&nbsp;</a></span>cr8r_avl_ft_initsla()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_avl_ft_initsla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__sla.html">cr8r_sla</a> *&#160;</td>
          <td class="paramname"><em>sla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>reserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *, void *)&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to initialize a <a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> and associated slab allocator. </p>
<p>Automatically initializes sla, points ft-&gt;base.data at sla, and sets ft-&gt;alloc and ft-&gt;free to <a class="el" href="container_8h.html#a67139601d9563b33acd69ec924eedfd3">cr8r_default_alloc_sla</a> and <a class="el" href="container_8h.html#a626e88c5f0d4d62a4d09d90df419a2c3">cr8r_default_free_sla</a> respectively. WARNING sla is always initialized, an initialized sla should not be passed and in particular to make multiple tables with the same slab allocator, call this once and then call <a class="el" href="avl_8h.html#a0a6ee6807d2e7c6c19e76690358c3e82">cr8r_avl_ft_init</a> or use a literal for subsequent function tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sla</td><td>slab allocator to initialize and point ft-&gt;base.data at. must be uninitialized. it is possible to have more information in ft-&gt;base.data by placing sla in a structure and additional information before or after it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single element (of the avl tree) in bytes. the size of a node (or slab allocator element) is offsetof(cr8r_avl_node, data) + size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reserve</td><td>how many nodes to reserve space for in the slab allocator initially. must not be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparison function. should not be NULL. some functions do not require it, but it is required to do anything useful with avl trees. See <a class="el" href="container_8h.html#adb4b61e520c0cee3c3d074635d6cdef4">cr8r_default_cmp</a> for a basic generic implementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>element composition function. can be NULL for all functions besides <a class="el" href="avl_8h.html#a1715ac023962286958c00d73753def60">cr8r_avl_insert_update</a>. called to combine an existing and new element when this function is called and the element to insert is already in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if cmp, sla, or reserve is NULL/0 or the slab allocator cannot reserve enough memory) </dd></dl>

</div>
</div>
<a id="a0957ddd9af1e5ccf143d75b9cba08508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0957ddd9af1e5ccf143d75b9cba08508">&#9670;&nbsp;</a></span>cr8r_avl_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_new </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>balance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new avl node and initialize it with given data. </p>
<p>Remember that ft-&gt;alloc(ft-&gt;base.data) will be called to allocate the node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to put into the node. This is generally a structure with conceptual "key" and "value" parts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left,right,parent</td><td>initial values for node pointers. This function does NOT adjust the links in these pointers. Generally left and right will be NULL and changed later. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">balance</td><td>avl balance value, generally 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new, initialized node, or NULL if ft-&gt;alloc fails </dd></dl>

</div>
</div>
<a id="a8a6b0ce9af0fbac11aabfb72a4fd7e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6b0ce9af0fbac11aabfb72a4fd7e88">&#9670;&nbsp;</a></span>cr8r_avl_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_avl_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node in an avl tree with a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>root node. This is a pointer to a pointer, so that if the root node changes, the change can be indicated to the caller. *r can be NULL to indicate an empty tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to insert. If no node with an element comparing equal to this element exists in the tree, a new node is created in the tree to hold it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if allocation fails or a node with the given element is already present in the tree, 1 if the element is not present and insertion suceeds. </dd></dl>

</div>
</div>
<a id="a6c4d1346b8e273264cdb96429f6cc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4d1346b8e273264cdb96429f6cc759">&#9670;&nbsp;</a></span>cr8r_avl_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_avl_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the node in an avl tree with a given value. </p>
<p>If multiple nodes with the same value exist in the tree, their order is unspecified and an unspecified one will be removed. Notice that <a class="el" href="avl_8h.html#a8a6b0ce9af0fbac11aabfb72a4fd7e88">cr8r_avl_insert</a> will never create a tree with duplicate nodes. The removed node is freed using ft-&gt;free. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>root node. This is a pointer to a pointer, so that if the root node changes, the change can be indicated to the caller. *r can be NULL to indicate an empty tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no node with the given element exists in the tree, 1 if successful </dd></dl>

</div>
</div>
<a id="a1715ac023962286958c00d73753def60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1715ac023962286958c00d73753def60">&#9670;&nbsp;</a></span>cr8r_avl_insert_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_avl_insert_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new node in an avl tree or modify an existing one with a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>root node. This is a pointer to a pointer, so that if the root node changes, the change can be indicated to the caller. *r can be NULL to indicate an empty tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to insert. If no node with an element comparing equal to this element exists in the tree, a new node is created in the tree to hold it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if allocation fails, 1 (AVL_INSERTED) if the element is not present and insertion suceeds, 2 (AVL_UPDATED) if an existing node was updated. </dd></dl>

</div>
</div>
<a id="a865c31955e987179e00b92c131d26335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865c31955e987179e00b92c131d26335">&#9670;&nbsp;</a></span>cr8r_avl_remove_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a given node from the tree containing it. </p>
<p>This modifies the containing tree and frees the removed node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>node to remove. n-&gt;left, n-&gt;right, and n-&gt;parent are used to find the rest of the tree and rebuild it without this node. This node is freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new root node of the tree that contained n, in case it changed. Can be NULL. </dd></dl>

</div>
</div>
<a id="ac16a624395fda046ef88933dafdc314c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16a624395fda046ef88933dafdc314c">&#9670;&nbsp;</a></span>cr8r_avl_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a given node to an existing tree. </p>
<p>The existing tree should not already contain a node with the same element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the root of the existing tree. Notice this is a pointer, not a pointer to a pointer as many other functions have. Can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the node to insert. Should not have links. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new root, in case it changed, or NULL if a node with the same element as n already exists. </dd></dl>

</div>
</div>
<a id="a9ce7ae4aa9f1ff38a0f098f5dfc5a375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce7ae4aa9f1ff38a0f098f5dfc5a375">&#9670;&nbsp;</a></span>cr8r_avl_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a given node from the tree containing it but do not free it. </p>
<p>This modifies the containing tree and clears the pointers in the node, but allows further use of the node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n</td><td>n-&gt;left, n-&gt;right, and n-&gt;parent are used to find the rest of the tree and rebuild it without this node, then cleared so this node is a singleton. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new root of the tree that contained the node, in case its root changed. Can be NULL if the last node was removed. </dd></dl>

</div>
</div>
<a id="a75f38c789b328479ae69d4cd0e2fb6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f38c789b328479ae69d4cd0e2fb6a1">&#9670;&nbsp;</a></span>cr8r_avl_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the node matching a given element in a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the root of the tree to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to find in the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node matching the given key, or NULL if no match exists. </dd></dl>

</div>
</div>
<a id="a909e9240331a0c26ec30cd039bb39284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909e9240331a0c26ec30cd039bb39284">&#9670;&nbsp;</a></span>cr8r_avl_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the deepest node that is a would be ancestor of a given element, a leaf node which is either the lower bound or upper bound of the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the root of the tree to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to search for in the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the last node in the tree on the search path for the given key. </dd></dl>

</div>
</div>
<a id="a7e48b77b0c84dde64dc0d7b3fcbb34fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e48b77b0c84dde64dc0d7b3fcbb34fd">&#9670;&nbsp;</a></span>cr8r_avl_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the root of the tree containing a given node. </p>
<p>Simply climbs the parent links repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>node in tree to find root of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the root of the tree containing n. </dd></dl>

</div>
</div>
<a id="aebafa6b9b40c87971610e91889b5cdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebafa6b9b40c87971610e91889b5cdb5">&#9670;&nbsp;</a></span>cr8r_avl_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the node in the tree with the lowest key. </p>
<p>Simply follows the left links repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the root of the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node with the lowest key in the tree </dd></dl>

</div>
</div>
<a id="a8a4ce6adaedb8065007151720d017a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4ce6adaedb8065007151720d017a37">&#9670;&nbsp;</a></span>cr8r_avl_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the inorder successor of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>node to find the successor of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inorder successor of n </dd></dl>

</div>
</div>
<a id="a4764d903a24c9bd721eb2a85943296ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4764d903a24c9bd721eb2a85943296ee">&#9670;&nbsp;</a></span>cr8r_avl_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the node in the tree with the greatest key. </p>
<p>Simply follows the right links repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the root of the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node with the greatest key in the tree </dd></dl>

</div>
</div>
<a id="adc53d6b26505c9659c48bf532da64950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc53d6b26505c9659c48bf532da64950">&#9670;&nbsp;</a></span>cr8r_avl_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the inorder predecessor of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>node to find the predecessor of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inorder predecessor of n </dd></dl>

</div>
</div>
<a id="acbd10ae542ec2a58bfcf1c923a43cb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd10ae542ec2a58bfcf1c923a43cb57">&#9670;&nbsp;</a></span>cr8r_avl_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the greatest element l in the tree so that l &lt;= key. </p>
<p>This is useful along with <a class="el" href="avl_8h.html#afb8c6e573d04691f416c96bbf373d2e1">cr8r_avl_upper_bound</a> for partitioning the tree into ranges, and partitions the inorder traversal in a nice way. In particular, if the tree has no duplicate keys, then cr8r_avl_upper_bound is the inorder successor of cr8r_avl_lower_bound, so if we start at <a class="el" href="avl_8h.html#aebafa6b9b40c87971610e91889b5cdb5">cr8r_avl_first</a> or some node known to have a key less than the key given to cr8r_avl_lower_bound, then we can do an inorder traversal with <a class="el" href="avl_8h.html#a8a4ce6adaedb8065007151720d017a37">cr8r_avl_next</a> from the starting point to the lower bound (inclusive). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>root of the tree to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to find a maximal inclusive lower bound of in the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a node whose key is a maximal inclusive lower bound </dd></dl>

</div>
</div>
<a id="afb8c6e573d04691f416c96bbf373d2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8c6e573d04691f416c96bbf373d2e1">&#9670;&nbsp;</a></span>cr8r_avl_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the lowest element u in the tree so that key &lt; u. </p>
<p>See <a class="el" href="avl_8h.html#acbd10ae542ec2a58bfcf1c923a43cb57">cr8r_avl_lower_bound</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>root of the tree to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to find a minimal exclusive upper bound of in the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a node whose key is a minimal exclusive upper bound </dd></dl>

</div>
</div>
<a id="aaed02212808cd23297e192b769986d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed02212808cd23297e192b769986d3c">&#9670;&nbsp;</a></span>cr8r_avl_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_avl_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an entire avl tree, freeing all nodes in the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the root of the tree, which is invalidated (unless ft-&gt;free doesn't invalidate nodes for some reason) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a384f8f81e2022f5443a404b6c3f90ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384f8f81e2022f5443a404b6c3f90ba0">&#9670;&nbsp;</a></span>cr8r_avl_swap_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_avl_swap_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two nodes in a tree, swapping their contents and then patching up links. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a,b</td><td>the nodes to swap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of the element. Only this is required rather than the entire function table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167669111edf2a29943c2c40def381ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167669111edf2a29943c2c40def381ce">&#9670;&nbsp;</a></span>cr8r_avl_decrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_decrease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the binary search tree invariant after decreasing the key for a single node. </p>
<p>After decreasing the key in a node, this function should be called, which then moves the node if necessary to ensure the tree is a BST. Only the given node should violate the BST condition. Also requires the tree have no duplicate keys. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the node that has had its key decreased and may need to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the root of the tree, in case it changes, or NULL if a duplicate key is encountered </dd></dl>

</div>
</div>
<a id="ad30a2cbae3d2e68a6953d15ee382a99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a2cbae3d2e68a6953d15ee382a99c">&#9670;&nbsp;</a></span>cr8r_avl_increase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_increase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the binary search tree invariant after increasing the key for a single node. </p>
<p>After increasing the key in a node, this function should be called, which then moves the node if necessary to ensure the tree is a BST. Only the given node should violate the BST condition. Also requires the tree have no duplicate keys. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the node that has had its key increased and may need to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the root of the tree, in case it changes, or NULL if a duplicate key is encountered </dd></dl>

</div>
</div>
<a id="a96c254012fdc9159a219b3bb132df912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c254012fdc9159a219b3bb132df912">&#9670;&nbsp;</a></span>cr8r_avl_first_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_first_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first node in a postorder traversal of the tree. </p>
<p>A postorder traversal visits the children of a node before the node, useful for evaluating expression trees and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>pointer to the root </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first node in a postorder traversal </dd></dl>

</div>
</div>
<a id="ac8c1f7d2adc02d947e94aff60ca4e2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c1f7d2adc02d947e94aff60ca4e2e2">&#9670;&nbsp;</a></span>cr8r_avl_next_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_next_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the postorder successor of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>current node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the next node in a postorder traversal </dd></dl>

</div>
</div>
<a id="abf8d1cd288fdb89241438668af4bb88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8d1cd288fdb89241438668af4bb88e">&#9670;&nbsp;</a></span>cr8r_avl_sift_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_avl_sift_down </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treat the avl tree as a max heap and sift down a given node. </p>
<p>If this node has had its key decreased but the avl tree is otherwise a max heap, this will restore the max heap invariant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the node to sift down </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a446d233258677dfa634aeb5b60857f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446d233258677dfa634aeb5b60857f15">&#9670;&nbsp;</a></span>cr8r_avl_heapify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_avl_heapify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the avl tree into a max heap in place. </p>
<p>This takes linear time. The shape of the tree is not changed. To change the ordering function of the heap, this function can just be called again on a formed heap with ft-&gt;cmp changed appropriately. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>root of the tree to heapify </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b28a2f3ba6dc52f38a5a8bb974f6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b28a2f3ba6dc52f38a5a8bb974f6e2">&#9670;&nbsp;</a></span>cr8r_avl_heappop_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a>* cr8r_avl_heappop_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> **&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treat the avl tree as a max heap and remove the top element. </p>
<p>Restores heap invariant afterwards </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>pointer to pointer to root node, updated to point to new root node afterwards </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to removed node, or NULL if *r was NULL </dd></dl>

</div>
</div>
<a id="a3cbcbe1cb3032c126794fb3fb6f55a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbcbe1cb3032c126794fb3fb6f55a45">&#9670;&nbsp;</a></span>cr8r_avl_reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_avl_reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__node.html">cr8r_avl_node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__avl__ft.html">cr8r_avl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the tree so that it is sorted according to a new ordering function. </p>
<p>Currently this works by heapifying the tree in place and then placing the nodes in order one by one, which takes n*log(n) time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>root of the tree to reorder, reordering is in place and does not change the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li><li class="navelem"><a class="el" href="avl_8h.html">avl.h</a></li>
    <li class="footer">Generated on Sat Mar 5 2022 05:19:55 for Crater Container Library by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
