<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/container.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Crater/index.html">Crater Container Library</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('container_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">container.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 Base function table for Crater containers </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Crater is a collection of generic data structures for C, including vectors, avl trees, heaps (binary, pairing, and minmax), kd trees, linked lists, hash tables, slab allocators, random number generators, and option parsing </p>

<p class="definition">Definition in file <a class="el" href="container_8h_source.html">container.h</a>.</p>
</div>
<p><a href="container_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base function table for all Crater containers.  <a href="structcr8r__base__ft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a200f4c65e946ac05c4f3af2cb4052688"><td class="memItemLeft" align="right" valign="top"><a id="a200f4c65e946ac05c4f3af2cb4052688"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a200f4c65e946ac05c4f3af2cb4052688">CR8R_FLA_CAST</a>(T,  p)&#160;&#160;&#160;(((union{__typeof__(p) data; T a;})(p)).a)</td></tr>
<tr class="memdesc:a200f4c65e946ac05c4f3af2cb4052688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a flexible length array member to a given type using union hackery sorcery. <br /></td></tr>
<tr class="separator:a200f4c65e946ac05c4f3af2cb4052688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79128caa105eb0990a2ee8227001846"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#aa79128caa105eb0990a2ee8227001846">CR8R_OUTER</a>(ptr,  T,  memb)&#160;&#160;&#160;((T*)((void*)(ptr) - offsetof(T, memb)))</td></tr>
<tr class="memdesc:aa79128caa105eb0990a2ee8227001846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to an intrusive data structure to a pointer to the outer structure containing it, based on the type of the outer structure.  <a href="container_8h.html#aa79128caa105eb0990a2ee8227001846">More...</a><br /></td></tr>
<tr class="separator:aa79128caa105eb0990a2ee8227001846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3571b1ff2e05aacbab97baa0c3de4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a2f3571b1ff2e05aacbab97baa0c3de4d">CR8R_OUTER_S</a>(ptr,  ft)&#160;&#160;&#160;(((void*)(ptr) - (ft)-&gt;base.size))</td></tr>
<tr class="memdesc:a2f3571b1ff2e05aacbab97baa0c3de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to an intrusive data structure to a pointer to the outer structure containing it, based on a function table.  <a href="container_8h.html#a2f3571b1ff2e05aacbab97baa0c3de4d">More...</a><br /></td></tr>
<tr class="separator:a2f3571b1ff2e05aacbab97baa0c3de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6371349b1d0a713fb6c5b5528cd14f55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a6371349b1d0a713fb6c5b5528cd14f55">CR8R_INNER</a>(ptr,  T,  memb)&#160;&#160;&#160;(((void*)(ptr) + offsetof(T, memb)))</td></tr>
<tr class="memdesc:a6371349b1d0a713fb6c5b5528cd14f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to an outer data structure to a pointer to the intrusive data structure within it, based on the type of the outer structure.  <a href="container_8h.html#a6371349b1d0a713fb6c5b5528cd14f55">More...</a><br /></td></tr>
<tr class="separator:a6371349b1d0a713fb6c5b5528cd14f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8918a1392d8b4a87a9e71b5ba99685"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a9c8918a1392d8b4a87a9e71b5ba99685">CR8R_INNER_S</a>(ptr,  ft)&#160;&#160;&#160;(((void*)(ptr) + (ft)-&gt;base.size))</td></tr>
<tr class="memdesc:a9c8918a1392d8b4a87a9e71b5ba99685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to an outer data structure to a pointer to the intrusive data structure within it, based on a function table.  <a href="container_8h.html#a9c8918a1392d8b4a87a9e71b5ba99685">More...</a><br /></td></tr>
<tr class="separator:a9c8918a1392d8b4a87a9e71b5ba99685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef326ff69e385ee0a22cae78a3c5b02"><td class="memItemLeft" align="right" valign="top"><a id="a7ef326ff69e385ee0a22cae78a3c5b02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a7ef326ff69e385ee0a22cae78a3c5b02">CR8R_ATTR_NO_SAN</a>(...)</td></tr>
<tr class="memdesc:a7ef326ff69e385ee0a22cae78a3c5b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent clang from reporting spurious errors when a length zero array is passed to a length annotated function parameter. <br /></td></tr>
<tr class="separator:a7ef326ff69e385ee0a22cae78a3c5b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6970e065db27984cca427f6b1df64df2"><td class="memItemLeft" align="right" valign="top"><a id="a6970e065db27984cca427f6b1df64df2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a6970e065db27984cca427f6b1df64df2">cr8r_walk_decision</a> { <b>CR8R_WALK_CONTINUE</b> = 0
, <b>CR8R_WALK_SKIP_CHILDREN</b> = 1
, <b>CR8R_WALK_STOP</b> = 2
 }</td></tr>
<tr class="memdesc:a6970e065db27984cca427f6b1df64df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to allow a callee/visitor to control the behavior of a tree traversal. <br /></td></tr>
<tr class="separator:a6970e065db27984cca427f6b1df64df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afe863262f21f39d2d95940863e10d883"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#afe863262f21f39d2d95940863e10d883">cr8r_default_new_size</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, uint64_t cap)</td></tr>
<tr class="memdesc:afe863262f21f39d2d95940863e10d883"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;new_size implementation (for vectors)  <a href="container_8h.html#afe863262f21f39d2d95940863e10d883">More...</a><br /></td></tr>
<tr class="separator:afe863262f21f39d2d95940863e10d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd45f43164682902b5de1b249f366f6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a0bd45f43164682902b5de1b249f366f6">cr8r_default_bump_size</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, uint64_t cap)</td></tr>
<tr class="memdesc:a0bd45f43164682902b5de1b249f366f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" increase-by-one ft-&gt;new_size implementation (for vectors)  <a href="container_8h.html#a0bd45f43164682902b5de1b249f366f6">More...</a><br /></td></tr>
<tr class="separator:a0bd45f43164682902b5de1b249f366f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298ab3d3cf336dc71468fd55493c6a1d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p, uint64_t cap)</td></tr>
<tr class="memdesc:a298ab3d3cf336dc71468fd55493c6a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;resize implementation (for vectors)  <a href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">More...</a><br /></td></tr>
<tr class="separator:a298ab3d3cf336dc71468fd55493c6a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8447aba675a3cac695143f54a30638"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a7c8447aba675a3cac695143f54a30638">cr8r_default_resize_pass</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p, uint64_t cap)</td></tr>
<tr class="memdesc:a7c8447aba675a3cac695143f54a30638"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" do-nothing ft-&gt;resize implementation (for vectors)  <a href="container_8h.html#a7c8447aba675a3cac695143f54a30638">More...</a><br /></td></tr>
<tr class="separator:a7c8447aba675a3cac695143f54a30638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4b61e520c0cee3c3d074635d6cdef4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#adb4b61e520c0cee3c3d074635d6cdef4">cr8r_default_cmp</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *a, const void *b)</td></tr>
<tr class="memdesc:adb4b61e520c0cee3c3d074635d6cdef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;cmp implementation  <a href="container_8h.html#adb4b61e520c0cee3c3d074635d6cdef4">More...</a><br /></td></tr>
<tr class="separator:adb4b61e520c0cee3c3d074635d6cdef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaed3e57335670ca2dfbc304b75fede2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#abaed3e57335670ca2dfbc304b75fede2">cr8r_default_swap</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *a, void *b)</td></tr>
<tr class="memdesc:abaed3e57335670ca2dfbc304b75fede2"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;swap implementation (for vectors)  <a href="container_8h.html#abaed3e57335670ca2dfbc304b75fede2">More...</a><br /></td></tr>
<tr class="separator:abaed3e57335670ca2dfbc304b75fede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb88fd6f69fc60ba46d1600247301aa0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#abb88fd6f69fc60ba46d1600247301aa0">cr8r_default_hash_u64</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *)</td></tr>
<tr class="memdesc:abb88fd6f69fc60ba46d1600247301aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;hash implementation for uint64_t (for hash tables)  <a href="container_8h.html#abb88fd6f69fc60ba46d1600247301aa0">More...</a><br /></td></tr>
<tr class="separator:abb88fd6f69fc60ba46d1600247301aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4394aa838c22ff90e79aae08215cdfba"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a4394aa838c22ff90e79aae08215cdfba">cr8r_default_hash</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *)</td></tr>
<tr class="memdesc:a4394aa838c22ff90e79aae08215cdfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;hash implementation (for hash tables)  <a href="container_8h.html#a4394aa838c22ff90e79aae08215cdfba">More...</a><br /></td></tr>
<tr class="separator:a4394aa838c22ff90e79aae08215cdfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3d055543718947686f2600a87bb38f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a7a3d055543718947686f2600a87bb38f">cr8r_default_hash_cstr</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *)</td></tr>
<tr class="memdesc:a7a3d055543718947686f2600a87bb38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;hash implementation for null terminated strings (for hash tables)  <a href="container_8h.html#a7a3d055543718947686f2600a87bb38f">More...</a><br /></td></tr>
<tr class="separator:a7a3d055543718947686f2600a87bb38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ff4cc5be3eba687bcfac84f6b05c5e"><td class="memItemLeft" align="right" valign="top"><a id="a90ff4cc5be3eba687bcfac84f6b05c5e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a90ff4cc5be3eba687bcfac84f6b05c5e">cr8r_default_cmp_u64</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)</td></tr>
<tr class="memdesc:a90ff4cc5be3eba687bcfac84f6b05c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;cmp implementation for uint64_t <br /></td></tr>
<tr class="separator:a90ff4cc5be3eba687bcfac84f6b05c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e71c6f60f2a255de6850c127fabfa56"><td class="memItemLeft" align="right" valign="top"><a id="a2e71c6f60f2a255de6850c127fabfa56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a2e71c6f60f2a255de6850c127fabfa56">cr8r_default_cmp_u8</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)</td></tr>
<tr class="memdesc:a2e71c6f60f2a255de6850c127fabfa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;cmp implementation for uint8_t <br /></td></tr>
<tr class="separator:a2e71c6f60f2a255de6850c127fabfa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f588a171900d29f4c70177c4bf4a214"><td class="memItemLeft" align="right" valign="top"><a id="a3f588a171900d29f4c70177c4bf4a214"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a3f588a171900d29f4c70177c4bf4a214">cr8r_default_cmp_i64</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)</td></tr>
<tr class="memdesc:a3f588a171900d29f4c70177c4bf4a214"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;cmp implementation for int64_t <br /></td></tr>
<tr class="separator:a3f588a171900d29f4c70177c4bf4a214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e18a2a1ac7dea3ced1b4dc320ef11b"><td class="memItemLeft" align="right" valign="top"><a id="ae0e18a2a1ac7dea3ced1b4dc320ef11b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#ae0e18a2a1ac7dea3ced1b4dc320ef11b">cr8r_default_cmp_cstr</a> (const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)</td></tr>
<tr class="memdesc:ae0e18a2a1ac7dea3ced1b4dc320ef11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;cmp implementation for null terminated strings <br /></td></tr>
<tr class="separator:ae0e18a2a1ac7dea3ced1b4dc320ef11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172f0e8f2b9c741f7de068cd700e40a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a0172f0e8f2b9c741f7de068cd700e40a">cr8r_default_replace</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *_a, void *_b)</td></tr>
<tr class="memdesc:a0172f0e8f2b9c741f7de068cd700e40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default" ft-&gt;add implementation (for avl trees and hash tables)  <a href="container_8h.html#a0172f0e8f2b9c741f7de068cd700e40a">More...</a><br /></td></tr>
<tr class="separator:a0172f0e8f2b9c741f7de068cd700e40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4bc179e0a30b22a9be58fccda45d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#adf4bc179e0a30b22a9be58fccda45d77">cr8r_default_free_pass</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *)</td></tr>
<tr class="memdesc:adf4bc179e0a30b22a9be58fccda45d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">ft-&gt;free implementation (for avl trees or circular lists) that does nothing  <a href="container_8h.html#adf4bc179e0a30b22a9be58fccda45d77">More...</a><br /></td></tr>
<tr class="separator:adf4bc179e0a30b22a9be58fccda45d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67139601d9563b33acd69ec924eedfd3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a67139601d9563b33acd69ec924eedfd3">cr8r_default_alloc_sla</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *)</td></tr>
<tr class="memdesc:a67139601d9563b33acd69ec924eedfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ft-&gt;alloc implementation (for avl trees or circular lists)  <a href="container_8h.html#a67139601d9563b33acd69ec924eedfd3">More...</a><br /></td></tr>
<tr class="separator:a67139601d9563b33acd69ec924eedfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e88c5f0d4d62a4d09d90df419a2c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a626e88c5f0d4d62a4d09d90df419a2c3">cr8r_default_free_sla</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *)</td></tr>
<tr class="memdesc:a626e88c5f0d4d62a4d09d90df419a2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ft-&gt;free implementation (for avl trees or circular lists)  <a href="container_8h.html#a626e88c5f0d4d62a4d09d90df419a2c3">More...</a><br /></td></tr>
<tr class="separator:a626e88c5f0d4d62a4d09d90df419a2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc2070a9246a4e03ef6571f40e5c0ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a3dc2070a9246a4e03ef6571f40e5c0ce">cr8r_default_free</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *)</td></tr>
<tr class="memdesc:a3dc2070a9246a4e03ef6571f40e5c0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">ft-&gt;del implementation (for hash tables or vectors)  <a href="container_8h.html#a3dc2070a9246a4e03ef6571f40e5c0ce">More...</a><br /></td></tr>
<tr class="separator:a3dc2070a9246a4e03ef6571f40e5c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2ab5471f326b55c5d7e5f17fdbe0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#aee2ab5471f326b55c5d7e5f17fdbe0a0">cr8r_default_copy_cstr</a> (<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *, const void *)</td></tr>
<tr class="memdesc:aee2ab5471f326b55c5d7e5f17fdbe0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ft-&gt;copy implementation for null terminated strings  <a href="container_8h.html#aee2ab5471f326b55c5d7e5f17fdbe0a0">More...</a><br /></td></tr>
<tr class="separator:aee2ab5471f326b55c5d7e5f17fdbe0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fa73a600bfb34e19cdba45aa1b0941"><td class="memItemLeft" align="right" valign="top"><a id="ae7fa73a600bfb34e19cdba45aa1b0941"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#ae7fa73a600bfb34e19cdba45aa1b0941">cr8r_powmod</a> (uint64_t b, uint64_t e, uint64_t n)</td></tr>
<tr class="memdesc:ae7fa73a600bfb34e19cdba45aa1b0941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise b to the power of e modulo n using binary exponentiation. <br /></td></tr>
<tr class="separator:ae7fa73a600bfb34e19cdba45aa1b0941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813122c6d690cdd6469f09dc7ebc3807"><td class="memItemLeft" align="right" valign="top"><a id="a813122c6d690cdd6469f09dc7ebc3807"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a813122c6d690cdd6469f09dc7ebc3807">cr8r_pow_u64</a> (uint64_t b, uint64_t e)</td></tr>
<tr class="memdesc:a813122c6d690cdd6469f09dc7ebc3807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise b to the power of e using binary exponentiation. <br /></td></tr>
<tr class="separator:a813122c6d690cdd6469f09dc7ebc3807"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa79128caa105eb0990a2ee8227001846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79128caa105eb0990a2ee8227001846">&#9670;&nbsp;</a></span>CR8R_OUTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CR8R_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memb&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((T*)((void*)(ptr) - offsetof(T, memb)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pointer to an intrusive data structure to a pointer to the outer structure containing it, based on the type of the outer structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the intrusive data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>type of the outer structure (NOT a pointer to its type) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memb</td><td>the name of the intrusive data structure member within the outer structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the outer structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00176">176</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="a2f3571b1ff2e05aacbab97baa0c3de4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3571b1ff2e05aacbab97baa0c3de4d">&#9670;&nbsp;</a></span>CR8R_OUTER_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CR8R_OUTER_S</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ft&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((void*)(ptr) - (ft)-&gt;base.size))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pointer to an intrusive data structure to a pointer to the outer structure containing it, based on a function table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the intrusive data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ft</td><td>function table pointer with ft-&gt;base.size equal to the offset of the intrusive data structure within the outer data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the outer structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00184">184</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="a6371349b1d0a713fb6c5b5528cd14f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6371349b1d0a713fb6c5b5528cd14f55">&#9670;&nbsp;</a></span>CR8R_INNER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CR8R_INNER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memb&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((void*)(ptr) + offsetof(T, memb)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pointer to an outer data structure to a pointer to the intrusive data structure within it, based on the type of the outer structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the outer data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>type of the outer structure (NOT a pointer to its type) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memb</td><td>the name of the intrusive data structure member within the outer structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the intrusive data structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00192">192</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="a9c8918a1392d8b4a87a9e71b5ba99685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8918a1392d8b4a87a9e71b5ba99685">&#9670;&nbsp;</a></span>CR8R_INNER_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CR8R_INNER_S</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ft&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((void*)(ptr) + (ft)-&gt;base.size))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pointer to an outer data structure to a pointer to the intrusive data structure within it, based on a function table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the outer data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ft</td><td>function table pointer with ft-&gt;base.size equal to the offset of the intrusive data structure within the outer data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the intrusive data structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00200">200</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afe863262f21f39d2d95940863e10d883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe863262f21f39d2d95940863e10d883">&#9670;&nbsp;</a></span>cr8r_default_new_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_default_new_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;new_size implementation (for vectors) </p>
<p>Doubles the capacity if it is nonzero, otherwise returns 8. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the capacity before resizing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>what capacity the vector should grow to </dd></dl>

</div>
</div>
<a id="a0bd45f43164682902b5de1b249f366f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd45f43164682902b5de1b249f366f6">&#9670;&nbsp;</a></span>cr8r_default_bump_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_default_bump_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" increase-by-one ft-&gt;new_size implementation (for vectors) </p>
<p>Increases the capacity by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the capacity before resizing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>what capacity the vector should grow to </dd></dl>

</div>
</div>
<a id="a298ab3d3cf336dc71468fd55493c6a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298ab3d3cf336dc71468fd55493c6a1d">&#9670;&nbsp;</a></span>cr8r_default_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;resize implementation (for vectors) </p>
<p>Calls "free" if the given capacity is 0 (note that freeing NULL is a valid no-op), otherwise calls realloc (note that reallocing NULL is valid and allocates a new buffer). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the buffer to resize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the capacity to resize to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resized buffer, or NULL on failure or if cap is 0 </dd></dl>

</div>
</div>
<a id="a7c8447aba675a3cac695143f54a30638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8447aba675a3cac695143f54a30638">&#9670;&nbsp;</a></span>cr8r_default_resize_pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_resize_pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" do-nothing ft-&gt;resize implementation (for vectors) </p>
<p>Always returns NULL, indicating the buffer could not be resized. This is convenient if you want to wrap a stack/static/thread local array as a vector, since such an array cannot be resized. </p><dl class="section return"><dt>Returns</dt><dd>NULL </dd></dl>

</div>
</div>
<a id="adb4b61e520c0cee3c3d074635d6cdef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4b61e520c0cee3c3d074635d6cdef4">&#9670;&nbsp;</a></span>cr8r_default_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_default_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;cmp implementation </p>
<p>Calls memcmp(a, b, ft-&gt;base.size) WARNING: this may have problems with padded structs or doubles since equal values can have different representations in memory. A custom implementation is preferable for padded structs, anything containing doubles, or scalar types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>the elements to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if a &lt; b, 0 if a == b, 1 if a &gt; b </dd></dl>

</div>
</div>
<a id="abaed3e57335670ca2dfbc304b75fede2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaed3e57335670ca2dfbc304b75fede2">&#9670;&nbsp;</a></span>cr8r_default_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_default_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;swap implementation (for vectors) </p>
<p>Creates a temporary buffer and swaps with memcpy, if a != b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>the elements to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb88fd6f69fc60ba46d1600247301aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb88fd6f69fc60ba46d1600247301aa0">&#9670;&nbsp;</a></span>cr8r_default_hash_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_default_hash_u64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;hash implementation for uint64_t (for hash tables) </p>
<p>Multiplies the value by a fixed prime and xors the high and low words of the 128 bit result </p>

</div>
</div>
<a id="a4394aa838c22ff90e79aae08215cdfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4394aa838c22ff90e79aae08215cdfba">&#9670;&nbsp;</a></span>cr8r_default_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_default_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;hash implementation (for hash tables) </p>
<p>WARNING: this may have problems with padded structs or doubles since equal values can have different representations in memory. A custom implementation is preferable for padded structs, anything containing doubles, or scalar types. </p>

</div>
</div>
<a id="a7a3d055543718947686f2600a87bb38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3d055543718947686f2600a87bb38f">&#9670;&nbsp;</a></span>cr8r_default_hash_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_default_hash_cstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;hash implementation for null terminated strings (for hash tables) </p>
<p>Uses the djb2 algorithm </p>

</div>
</div>
<a id="a0172f0e8f2b9c741f7de068cd700e40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0172f0e8f2b9c741f7de068cd700e40a">&#9670;&nbsp;</a></span>cr8r_default_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_default_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Default" ft-&gt;add implementation (for avl trees and hash tables) </p>
<p>Simply replaces the existing value with the new value </p>

</div>
</div>
<a id="adf4bc179e0a30b22a9be58fccda45d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4bc179e0a30b22a9be58fccda45d77">&#9670;&nbsp;</a></span>cr8r_default_free_pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_default_free_pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ft-&gt;free implementation (for avl trees or circular lists) that does nothing </p>
<p>Useful to allow temporarily adding stack allocated nodes, or to temporarily disable freeing nodes so one can be removed but still have some processing done on it via an existing pointer before freeing it. </p>

</div>
</div>
<a id="a67139601d9563b33acd69ec924eedfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67139601d9563b33acd69ec924eedfd3">&#9670;&nbsp;</a></span>cr8r_default_alloc_sla()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_alloc_sla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ft-&gt;alloc implementation (for avl trees or circular lists) </p>
<p>Wraps a slab allocator. WARNING: ft-&gt;base.data must point to a slab allocator ( <a class="el" href="structcr8r__sla.html">cr8r_sla</a> ) with the appropriate element size. Remember, the element size of the slab allocator should be the node size, not the element size, of the container (avl tree or circular list). See <a class="el" href="avl_8h.html#afef37e961bb3fd70a7c0dca8c0b162cf">cr8r_avl_ft_initsla</a> and <a class="el" href="cll_8h.html#ac4965c643199d16bd84fbc4bfc8b5e54">cr8r_cll_ft_initsla</a>. </p>

</div>
</div>
<a id="a626e88c5f0d4d62a4d09d90df419a2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e88c5f0d4d62a4d09d90df419a2c3">&#9670;&nbsp;</a></span>cr8r_default_free_sla()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_default_free_sla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ft-&gt;free implementation (for avl trees or circular lists) </p>
<p>Wraps a slab allocator. WARNING: ft-&gt;base.data must point to a slab allocator ( <a class="el" href="structcr8r__sla.html">cr8r_sla</a> ) with the appropriate element size. Remember, the element size of the slab allocator should be the node size, not the element size, of the container (avl tree or circular list). See <a class="el" href="cll_8h.html#ac4965c643199d16bd84fbc4bfc8b5e54">cr8r_cll_ft_initsla</a> and <a class="el" href="cll_8h.html#ac4965c643199d16bd84fbc4bfc8b5e54">cr8r_cll_ft_initsla</a>. </p>

</div>
</div>
<a id="a3dc2070a9246a4e03ef6571f40e5c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc2070a9246a4e03ef6571f40e5c0ce">&#9670;&nbsp;</a></span>cr8r_default_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_default_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ft-&gt;del implementation (for hash tables or vectors) </p>
<p>Wraps free(). Keep in mind that the second argument is a pointer to an element and is dereferenced before being freed. For example, malloc'd C strings are stored as single pointers, so a vector of C strings is really a vector of pointers, and a pointer to an element of such a vector is a pointer to a pointer to some null terminated character sequence. </p>

</div>
</div>
<a id="aee2ab5471f326b55c5d7e5f17fdbe0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2ab5471f326b55c5d7e5f17fdbe0a0">&#9670;&nbsp;</a></span>cr8r_default_copy_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_default_copy_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ft-&gt;copy implementation for null terminated strings </p>
<p>Wraps strdup. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li><li class="navelem"><a class="el" href="container_8h.html">container.h</a></li>
    <li class="footer">Generated on Mon Feb 12 2024 01:19:32 for Crater Container Library by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
