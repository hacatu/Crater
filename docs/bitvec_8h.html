<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/bitvec.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Crater/index.html">Crater Container Library</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('bitvec_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bitvec.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 A vector of booleans/bits</dd></dl>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>

<p class="definition">Definition in file <a class="el" href="bitvec_8h_source.html">bitvec.h</a>.</p>
</div>
<p><a href="bitvec_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit vector Take care if manipulating these fields directly, this should only be done if the functions in this file are not sufficient.  <a href="structcr8r__bvec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for bit vector.  <a href="structcr8r__bvec__ft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abfa434030a7ea083665506782c3cd6de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#abfa434030a7ea083665506782c3cd6de">cr8r_bvec_init</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *, uint64_t bits)</td></tr>
<tr class="memdesc:abfa434030a7ea083665506782c3cd6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a bit vector with an empty buffer of a given capacity.  <a href="bitvec_8h.html#abfa434030a7ea083665506782c3cd6de">More...</a><br /></td></tr>
<tr class="separator:abfa434030a7ea083665506782c3cd6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e1de9c86cbab628eeccc672378a77d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#af1e1de9c86cbab628eeccc672378a77d">cr8r_bvec_delete</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *)</td></tr>
<tr class="memdesc:af1e1de9c86cbab628eeccc672378a77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the buffer of a bit vector.  <a href="bitvec_8h.html#af1e1de9c86cbab628eeccc672378a77d">More...</a><br /></td></tr>
<tr class="separator:af1e1de9c86cbab628eeccc672378a77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4324266f980f29b1238cf11804e8efe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a4324266f980f29b1238cf11804e8efe5">cr8r_bvec_copy</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *dest, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *src, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *)</td></tr>
<tr class="memdesc:a4324266f980f29b1238cf11804e8efe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a bit vector.  <a href="bitvec_8h.html#a4324266f980f29b1238cf11804e8efe5">More...</a><br /></td></tr>
<tr class="separator:a4324266f980f29b1238cf11804e8efe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9984bb3d5d386047fe128d06f33255ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a9984bb3d5d386047fe128d06f33255ea">cr8r_bvec_sub</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *dest, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *src, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a9984bb3d5d386047fe128d06f33255ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a slice of a bit vector.  <a href="bitvec_8h.html#a9984bb3d5d386047fe128d06f33255ea">More...</a><br /></td></tr>
<tr class="separator:a9984bb3d5d386047fe128d06f33255ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f299c175d12e26f2551d17b74a9ebe8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a0f299c175d12e26f2551d17b74a9ebe8">cr8r_bvec_resize</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *, uint64_t bits)</td></tr>
<tr class="memdesc:a0f299c175d12e26f2551d17b74a9ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a bit vector's reserved buffer.  <a href="bitvec_8h.html#a0f299c175d12e26f2551d17b74a9ebe8">More...</a><br /></td></tr>
<tr class="separator:a0f299c175d12e26f2551d17b74a9ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3f961f1aca497b2bc058655d9e4bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a03b3f961f1aca497b2bc058655d9e4bb">cr8r_bvec_trim</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *)</td></tr>
<tr class="memdesc:a03b3f961f1aca497b2bc058655d9e4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a bit vector's reserved buffer to its length.  <a href="bitvec_8h.html#a03b3f961f1aca497b2bc058655d9e4bb">More...</a><br /></td></tr>
<tr class="separator:a03b3f961f1aca497b2bc058655d9e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081043832f6276c985cad80972de2df5"><td class="memItemLeft" align="right" valign="top"><a id="a081043832f6276c985cad80972de2df5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a081043832f6276c985cad80972de2df5">cr8r_bvec_clear</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a081043832f6276c985cad80972de2df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets len to 0. <br /></td></tr>
<tr class="separator:a081043832f6276c985cad80972de2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeef86adf84ae111ddcc1ca0da672a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#abeef86adf84ae111ddcc1ca0da672a24">cr8r_bvec_shuffle</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:abeef86adf84ae111ddcc1ca0da672a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the bit vector into a random permutation.  <a href="bitvec_8h.html#abeef86adf84ae111ddcc1ca0da672a24">More...</a><br /></td></tr>
<tr class="separator:abeef86adf84ae111ddcc1ca0da672a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e207b28bf74d883ef61e855cc787284"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a9e207b28bf74d883ef61e855cc787284">cr8r_bvec_get</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t i)</td></tr>
<tr class="memdesc:a9e207b28bf74d883ef61e855cc787284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit at a given index WITH bounds checking.  <a href="bitvec_8h.html#a9e207b28bf74d883ef61e855cc787284">More...</a><br /></td></tr>
<tr class="separator:a9e207b28bf74d883ef61e855cc787284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5bec2ece045e3f10c3452e4c7db22f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a7d5bec2ece045e3f10c3452e4c7db22f">cr8r_bvec_getu</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t i)</td></tr>
<tr class="memdesc:a7d5bec2ece045e3f10c3452e4c7db22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit at a given index WITHOUT bounds checking.  <a href="bitvec_8h.html#a7d5bec2ece045e3f10c3452e4c7db22f">More...</a><br /></td></tr>
<tr class="separator:a7d5bec2ece045e3f10c3452e4c7db22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd977d984e66f3775fc904a309a91d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#abd977d984e66f3775fc904a309a91d59">cr8r_bvec_getx</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, int64_t i)</td></tr>
<tr class="memdesc:abd977d984e66f3775fc904a309a91d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at a given index, with support for negative indices, WITH bounds checking.  <a href="bitvec_8h.html#abd977d984e66f3775fc904a309a91d59">More...</a><br /></td></tr>
<tr class="separator:abd977d984e66f3775fc904a309a91d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f1f68f8e9fec4bd24a934a8d7d9e8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a29f1f68f8e9fec4bd24a934a8d7d9e8f">cr8r_bvec_getux</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, int64_t i)</td></tr>
<tr class="memdesc:a29f1f68f8e9fec4bd24a934a8d7d9e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at a given index, with support for negative indices, WITHOUT bounds checking.  <a href="bitvec_8h.html#a29f1f68f8e9fec4bd24a934a8d7d9e8f">More...</a><br /></td></tr>
<tr class="separator:a29f1f68f8e9fec4bd24a934a8d7d9e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bb75153c03361a72012f37d31fc768"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a02bb75153c03361a72012f37d31fc768">cr8r_bvec_set</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t i, bool b)</td></tr>
<tr class="memdesc:a02bb75153c03361a72012f37d31fc768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit at a given index WITH bounds checking.  <a href="bitvec_8h.html#a02bb75153c03361a72012f37d31fc768">More...</a><br /></td></tr>
<tr class="separator:a02bb75153c03361a72012f37d31fc768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5158592a1d74ac64886a7296843eeff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a5158592a1d74ac64886a7296843eeff5">cr8r_bvec_setu</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t i, bool b)</td></tr>
<tr class="memdesc:a5158592a1d74ac64886a7296843eeff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit at a given index WITHOUT bounds checking.  <a href="bitvec_8h.html#a5158592a1d74ac64886a7296843eeff5">More...</a><br /></td></tr>
<tr class="separator:a5158592a1d74ac64886a7296843eeff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b9da4827f4c997be40fabb4c08478c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#ac0b9da4827f4c997be40fabb4c08478c">cr8r_bvec_setx</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, int64_t i, bool b)</td></tr>
<tr class="memdesc:ac0b9da4827f4c997be40fabb4c08478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element at a given index, with support for negative indices, WITH bounds checking.  <a href="bitvec_8h.html#ac0b9da4827f4c997be40fabb4c08478c">More...</a><br /></td></tr>
<tr class="separator:ac0b9da4827f4c997be40fabb4c08478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0edd35ec90cf85083e7fcc4dbc3828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#acf0edd35ec90cf85083e7fcc4dbc3828">cr8r_bvec_setux</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, int64_t i, bool b)</td></tr>
<tr class="memdesc:acf0edd35ec90cf85083e7fcc4dbc3828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element at a given index, with support for negative indices, WITHOUT bounds checking.  <a href="bitvec_8h.html#acf0edd35ec90cf85083e7fcc4dbc3828">More...</a><br /></td></tr>
<tr class="separator:acf0edd35ec90cf85083e7fcc4dbc3828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1842f069dbc2618ad9dbe5506ccaffe5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a1842f069dbc2618ad9dbe5506ccaffe5">cr8r_bvec_len</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a1842f069dbc2618ad9dbe5506ccaffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a bit vector.  <a href="bitvec_8h.html#a1842f069dbc2618ad9dbe5506ccaffe5">More...</a><br /></td></tr>
<tr class="separator:a1842f069dbc2618ad9dbe5506ccaffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc787e7af493131b870c1ce97963368"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a6cc787e7af493131b870c1ce97963368">cr8r_bvec_pushr</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *, bool b)</td></tr>
<tr class="memdesc:a6cc787e7af493131b870c1ce97963368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a bit to the right hand end of a bit vector.  <a href="bitvec_8h.html#a6cc787e7af493131b870c1ce97963368">More...</a><br /></td></tr>
<tr class="separator:a6cc787e7af493131b870c1ce97963368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ccaf94e8d4cbef7176cc24cc13df75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a38ccaf94e8d4cbef7176cc24cc13df75">cr8r_bvec_popr</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, int *status)</td></tr>
<tr class="memdesc:a38ccaf94e8d4cbef7176cc24cc13df75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a bit from the right hand end of a bit vector.  <a href="bitvec_8h.html#a38ccaf94e8d4cbef7176cc24cc13df75">More...</a><br /></td></tr>
<tr class="separator:a38ccaf94e8d4cbef7176cc24cc13df75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5e5f13db50fd335b1fe772c70bf2c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a1c5e5f13db50fd335b1fe772c70bf2c7">cr8r_bvec_pushl</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *, bool b)</td></tr>
<tr class="memdesc:a1c5e5f13db50fd335b1fe772c70bf2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a bit to the left hand end of a bit vector.  <a href="bitvec_8h.html#a1c5e5f13db50fd335b1fe772c70bf2c7">More...</a><br /></td></tr>
<tr class="separator:a1c5e5f13db50fd335b1fe772c70bf2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33d03514079bb7a977eda663bf3c4af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#aa33d03514079bb7a977eda663bf3c4af">cr8r_bvec_popl</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, int *status)</td></tr>
<tr class="memdesc:aa33d03514079bb7a977eda663bf3c4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a bit from the left hand end of a bit vector.  <a href="bitvec_8h.html#aa33d03514079bb7a977eda663bf3c4af">More...</a><br /></td></tr>
<tr class="separator:aa33d03514079bb7a977eda663bf3c4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e93a0b39ac2aad3b295ebc8e50c21d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a6e93a0b39ac2aad3b295ebc8e50c21d9">cr8r_bvec_forEachPermutation</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, void(*f)(const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, void *data), void *data)</td></tr>
<tr class="memdesc:a6e93a0b39ac2aad3b295ebc8e50c21d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on every permutation of a bit vector.  <a href="bitvec_8h.html#a6e93a0b39ac2aad3b295ebc8e50c21d9">More...</a><br /></td></tr>
<tr class="separator:a6e93a0b39ac2aad3b295ebc8e50c21d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb0504e94b02093d2380b140106c109"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a1eb0504e94b02093d2380b140106c109">cr8r_bvec_combine</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *dest, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *src_a, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *src_b, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *)</td></tr>
<tr class="memdesc:a1eb0504e94b02093d2380b140106c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new bit vector by concatenating copies of two given bit vectors.  <a href="bitvec_8h.html#a1eb0504e94b02093d2380b140106c109">More...</a><br /></td></tr>
<tr class="separator:a1eb0504e94b02093d2380b140106c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096d7d815df770a1ac929bdd3877f308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a096d7d815df770a1ac929bdd3877f308">cr8r_bvec_augment</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *self, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *other, <a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *)</td></tr>
<tr class="memdesc:a096d7d815df770a1ac929bdd3877f308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a copy of another bit vector to a given bit vector.  <a href="bitvec_8h.html#a096d7d815df770a1ac929bdd3877f308">More...</a><br /></td></tr>
<tr class="separator:a096d7d815df770a1ac929bdd3877f308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41112b46d79a9d70b5f257c5a8d8b71b"><td class="memItemLeft" align="right" valign="top"><a id="a41112b46d79a9d70b5f257c5a8d8b71b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a41112b46d79a9d70b5f257c5a8d8b71b">cr8r_bvec_all</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a41112b46d79a9d70b5f257c5a8d8b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if all bits are set. <br /></td></tr>
<tr class="separator:a41112b46d79a9d70b5f257c5a8d8b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6090b61869ac4cf68ea495d70aa9aeb1"><td class="memItemLeft" align="right" valign="top"><a id="a6090b61869ac4cf68ea495d70aa9aeb1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a6090b61869ac4cf68ea495d70aa9aeb1">cr8r_bvec_any</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a6090b61869ac4cf68ea495d70aa9aeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if any bits. <br /></td></tr>
<tr class="separator:a6090b61869ac4cf68ea495d70aa9aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566a50232ef191288c4994f8fde48430"><td class="memItemLeft" align="right" valign="top"><a id="a566a50232ef191288c4994f8fde48430"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a566a50232ef191288c4994f8fde48430">cr8r_bvec_popcount</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a566a50232ef191288c4994f8fde48430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of bits set. <br /></td></tr>
<tr class="separator:a566a50232ef191288c4994f8fde48430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1470ae0229428512d0cb1e118197fbb"><td class="memItemLeft" align="right" valign="top"><a id="ad1470ae0229428512d0cb1e118197fbb"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#ad1470ae0229428512d0cb1e118197fbb">cr8r_bvec_clz</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:ad1470ae0229428512d0cb1e118197fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zeros (starting from the largest index self-&gt;len - 1) <br /></td></tr>
<tr class="separator:ad1470ae0229428512d0cb1e118197fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fe5539baeac37a56d3298740dd6d2d"><td class="memItemLeft" align="right" valign="top"><a id="a60fe5539baeac37a56d3298740dd6d2d"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a60fe5539baeac37a56d3298740dd6d2d">cr8r_bvec_ctz</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a60fe5539baeac37a56d3298740dd6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count trailing zeros (starting from the smallest index 0) <br /></td></tr>
<tr class="separator:a60fe5539baeac37a56d3298740dd6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ad61ab46609a33ca6bbcd81eb9de19"><td class="memItemLeft" align="right" valign="top"><a id="ac9ad61ab46609a33ca6bbcd81eb9de19"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#ac9ad61ab46609a33ca6bbcd81eb9de19">cr8r_bvec_clo</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:ac9ad61ab46609a33ca6bbcd81eb9de19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading ones (starting from the largest index self-&gt;len - 1) <br /></td></tr>
<tr class="separator:ac9ad61ab46609a33ca6bbcd81eb9de19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0fcb79506ec6fcd8e4b8bb6635e19d"><td class="memItemLeft" align="right" valign="top"><a id="a0a0fcb79506ec6fcd8e4b8bb6635e19d"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a0a0fcb79506ec6fcd8e4b8bb6635e19d">cr8r_bvec_cto</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a0a0fcb79506ec6fcd8e4b8bb6635e19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count trailing ones (starting from the smallest index 0) <br /></td></tr>
<tr class="separator:a0a0fcb79506ec6fcd8e4b8bb6635e19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93625bd745b6126476f2ba4b13d3e36f"><td class="memItemLeft" align="right" valign="top"><a id="a93625bd745b6126476f2ba4b13d3e36f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a93625bd745b6126476f2ba4b13d3e36f">cr8r_bvec_icompl</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *)</td></tr>
<tr class="memdesc:a93625bd745b6126476f2ba4b13d3e36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise negate (~) a bit vector in place. <br /></td></tr>
<tr class="separator:a93625bd745b6126476f2ba4b13d3e36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe11b2d76d18c03802f05c3bd6ee66"><td class="memItemLeft" align="right" valign="top"><a id="ac6fe11b2d76d18c03802f05c3bd6ee66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#ac6fe11b2d76d18c03802f05c3bd6ee66">cr8r_bvec_iand</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *self, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *other)</td></tr>
<tr class="memdesc:ac6fe11b2d76d18c03802f05c3bd6ee66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and (&amp;=) a bit vector with another in place If the other vector is shorter, missing bits are treated as zero. <br /></td></tr>
<tr class="separator:ac6fe11b2d76d18c03802f05c3bd6ee66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013a02b1c7945fc350039aa097315e84"><td class="memItemLeft" align="right" valign="top"><a id="a013a02b1c7945fc350039aa097315e84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a013a02b1c7945fc350039aa097315e84">cr8r_bvec_ior</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *self, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *other)</td></tr>
<tr class="memdesc:a013a02b1c7945fc350039aa097315e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or (|=) a bit vector with another in place If the other vector is shorter, missing bits are treated as zero. <br /></td></tr>
<tr class="separator:a013a02b1c7945fc350039aa097315e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbec680b8afa08db7bdb929dd204d7e0"><td class="memItemLeft" align="right" valign="top"><a id="afbec680b8afa08db7bdb929dd204d7e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#afbec680b8afa08db7bdb929dd204d7e0">cr8r_bvec_ixor</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *self, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *other)</td></tr>
<tr class="memdesc:afbec680b8afa08db7bdb929dd204d7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor (^=) a bit vector with another in place If the other vector is shorter, missing bits are treated as zero. <br /></td></tr>
<tr class="separator:afbec680b8afa08db7bdb929dd204d7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8816e9364804dff6c834f5faf6753afc"><td class="memItemLeft" align="right" valign="top"><a id="a8816e9364804dff6c834f5faf6753afc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a8816e9364804dff6c834f5faf6753afc">cr8r_bvec_any_range</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a8816e9364804dff6c834f5faf6753afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if any bit in the range [a, b) is set If the range is invalid, 0 is returned. <br /></td></tr>
<tr class="separator:a8816e9364804dff6c834f5faf6753afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0590d16b072779a04c242c5e97670e1"><td class="memItemLeft" align="right" valign="top"><a id="ab0590d16b072779a04c242c5e97670e1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#ab0590d16b072779a04c242c5e97670e1">cr8r_bvec_all_range</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:ab0590d16b072779a04c242c5e97670e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if all bits in the range [a, b) are set If the range is invalid, 0 is returned. <br /></td></tr>
<tr class="separator:ab0590d16b072779a04c242c5e97670e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e95fb921183150ace4bf19bd0df661a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a1e95fb921183150ace4bf19bd0df661a">cr8r_bvec_set_range</a> (<a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, uint64_t a, uint64_t b, bool v)</td></tr>
<tr class="memdesc:a1e95fb921183150ace4bf19bd0df661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all bits in a range WITH bounds checking.  <a href="bitvec_8h.html#a1e95fb921183150ace4bf19bd0df661a">More...</a><br /></td></tr>
<tr class="separator:a1e95fb921183150ace4bf19bd0df661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5c1f4077c0f6cfe71a33b4cbe71c19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#a4d5c1f4077c0f6cfe71a33b4cbe71c19">cr8r_bvec_cmp</a> (const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *a, const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *b)</td></tr>
<tr class="memdesc:a4d5c1f4077c0f6cfe71a33b4cbe71c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compare two bit vectors.  <a href="bitvec_8h.html#a4d5c1f4077c0f6cfe71a33b4cbe71c19">More...</a><br /></td></tr>
<tr class="separator:a4d5c1f4077c0f6cfe71a33b4cbe71c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acb1d85b06477aed27852b22bfe2a500e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvec_8h.html#acb1d85b06477aed27852b22bfe2a500e">cr8r_bvecft</a></td></tr>
<tr class="memdesc:acb1d85b06477aed27852b22bfe2a500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for bit vectors.  <a href="bitvec_8h.html#acb1d85b06477aed27852b22bfe2a500e">More...</a><br /></td></tr>
<tr class="separator:acb1d85b06477aed27852b22bfe2a500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abfa434030a7ea083665506782c3cd6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa434030a7ea083665506782c3cd6de">&#9670;&nbsp;</a></span>cr8r_bvec_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a bit vector with an empty buffer of a given capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bits</td><td>how many bits to reserve space for initially (will be rounded up to a multiple of 64) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="af1e1de9c86cbab628eeccc672378a77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e1de9c86cbab628eeccc672378a77d">&#9670;&nbsp;</a></span>cr8r_bvec_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_bvec_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the buffer of a bit vector. </p>
<p>ft-&gt;resize is called to "resize" to 0. the fields of the vector are all zeroed out </p>

</div>
</div>
<a id="a4324266f980f29b1238cf11804e8efe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4324266f980f29b1238cf11804e8efe5">&#9670;&nbsp;</a></span>cr8r_bvec_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a bit vector. </p>
<p>dest should NOT be initialized or its buffer will be leaked! The copy's capacity is only its length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the bit vector to copy TO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the bit vector to copy FROM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="a9984bb3d5d386047fe128d06f33255ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9984bb3d5d386047fe128d06f33255ea">&#9670;&nbsp;</a></span>cr8r_bvec_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a slice of a bit vector. </p>
<p>dest should NOT be initialized or its buffer will be leaked! Copies the range [ a : b ) from src to dest. The copy's capacity is only its length (b - a). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the bit vector to copy TO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the bit vector to copy FROM </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive start index and exclusive end index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure or invalid bounds) </dd></dl>

</div>
</div>
<a id="a0f299c175d12e26f2551d17b74a9ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f299c175d12e26f2551d17b74a9ebe8">&#9670;&nbsp;</a></span>cr8r_bvec_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a bit vector's reserved buffer. </p>
<p>Can extend or shrink the buffer, but cannot make it smaller than its length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the target capacity, should not be less than the current length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation or invalid bounds) </dd></dl>

</div>
</div>
<a id="a03b3f961f1aca497b2bc058655d9e4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b3f961f1aca497b2bc058655d9e4bb">&#9670;&nbsp;</a></span>cr8r_bvec_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a bit vector's reserved buffer to its length. </p>
<p>Exactly like <a class="el" href="bitvec_8h.html#a0f299c175d12e26f2551d17b74a9ebe8">cr8r_bvec_resize</a> with self-&gt;len as the cap parameter </p><dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation, shouldn't happen unless ft-&gt;resize can fail to shrink) </dd></dl>

</div>
</div>
<a id="abeef86adf84ae111ddcc1ca0da672a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeef86adf84ae111ddcc1ca0da672a24">&#9670;&nbsp;</a></span>cr8r_bvec_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_bvec_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the bit vector into a random permutation. </p>
<p>Actually works by counting the number of bits set and redistributing them. </p>

</div>
</div>
<a id="a9e207b28bf74d883ef61e855cc787284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e207b28bf74d883ef61e855cc787284">&#9670;&nbsp;</a></span>cr8r_bvec_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bit at a given index WITH bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit at index i, or 0 if i is out of bounds </dd></dl>

</div>
</div>
<a id="a7d5bec2ece045e3f10c3452e4c7db22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5bec2ece045e3f10c3452e4c7db22f">&#9670;&nbsp;</a></span>cr8r_bvec_getu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_getu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bit at a given index WITHOUT bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit at index i, or 0 if i is out of bounds </dd></dl>

</div>
</div>
<a id="abd977d984e66f3775fc904a309a91d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd977d984e66f3775fc904a309a91d59">&#9670;&nbsp;</a></span>cr8r_bvec_getx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_getx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at a given index, with support for negative indices, WITH bounds checking. </p>
<p>Negative indicies work backwards, with -1 referring to the last element and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit at index i, or 0 if i is out of bounds </dd></dl>

</div>
</div>
<a id="a29f1f68f8e9fec4bd24a934a8d7d9e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f1f68f8e9fec4bd24a934a8d7d9e8f">&#9670;&nbsp;</a></span>cr8r_bvec_getux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_getux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at a given index, with support for negative indices, WITHOUT bounds checking. </p>
<p>Negative indicies work backwards, with -1 referring to the last element and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit at index i, or 0 if i is out of bounds </dd></dl>

</div>
</div>
<a id="a02bb75153c03361a72012f37d31fc768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bb75153c03361a72012f37d31fc768">&#9670;&nbsp;</a></span>cr8r_bvec_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bit at a given index WITH bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, or 0 if i is out of bounds </dd></dl>

</div>
</div>
<a id="a5158592a1d74ac64886a7296843eeff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5158592a1d74ac64886a7296843eeff5">&#9670;&nbsp;</a></span>cr8r_bvec_setu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_bvec_setu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bit at a given index WITHOUT bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b9da4827f4c997be40fabb4c08478c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b9da4827f4c997be40fabb4c08478c">&#9670;&nbsp;</a></span>cr8r_bvec_setx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_setx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the element at a given index, with support for negative indices, WITH bounds checking. </p>
<p>Negative indicies work backwards, with -1 referring to the last element and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit at index i, or 0 if i is out of bounds </dd></dl>

</div>
</div>
<a id="acf0edd35ec90cf85083e7fcc4dbc3828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0edd35ec90cf85083e7fcc4dbc3828">&#9670;&nbsp;</a></span>cr8r_bvec_setux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_bvec_setux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the element at a given index, with support for negative indices, WITHOUT bounds checking. </p>
<p>Negative indicies work backwards, with -1 referring to the last element and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1842f069dbc2618ad9dbe5506ccaffe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1842f069dbc2618ad9dbe5506ccaffe5">&#9670;&nbsp;</a></span>cr8r_bvec_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_bvec_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a bit vector. </p>
<p>Simply returns self-&gt;len </p><dl class="section return"><dt>Returns</dt><dd>the length of the vector </dd></dl>

</div>
</div>
<a id="a6cc787e7af493131b870c1ce97963368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc787e7af493131b870c1ce97963368">&#9670;&nbsp;</a></span>cr8r_bvec_pushr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_pushr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a bit to the right hand end of a bit vector. </p>
<p>This is an O(1) operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the bit to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a38ccaf94e8d4cbef7176cc24cc13df75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ccaf94e8d4cbef7176cc24cc13df75">&#9670;&nbsp;</a></span>cr8r_bvec_popr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_popr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a bit from the right hand end of a bit vector. </p>
<p>Vectors are arranged with increasing indicies at increasing memory addresses, so this is an O(1) operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>if not NULL, *status will be set to 1 on success or 0 on failure (if the bit vector was empty) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit that was removed </dd></dl>

</div>
</div>
<a id="a1c5e5f13db50fd335b1fe772c70bf2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5e5f13db50fd335b1fe772c70bf2c7">&#9670;&nbsp;</a></span>cr8r_bvec_pushl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_pushl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a bit to the left hand end of a bit vector. </p>
<p>Avoid if possible.</p>
<p>Don't do this. This is an O(n) operation because bit vectors are arranged with increasing indicies at increasing memory addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the bit to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="aa33d03514079bb7a977eda663bf3c4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33d03514079bb7a977eda663bf3c4af">&#9670;&nbsp;</a></span>cr8r_bvec_popl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_popl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a bit from the left hand end of a bit vector. </p>
<p>Avoid if possible.</p>
<p>Don't do this. This is an O(n) operation because bit vectors are arranged with increasing indicies at increasing memory addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>if not NULL, *status will be set to 1 on success or 0 on failure (if the bit vector was empty) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bit that was removed </dd></dl>

</div>
</div>
<a id="a6e93a0b39ac2aad3b295ebc8e50c21d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e93a0b39ac2aad3b295ebc8e50c21d9">&#9670;&nbsp;</a></span>cr8r_bvec_forEachPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_bvec_forEachPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *, void *data)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on every permutation of a bit vector. </p>
<p>The bit vector is actually permuted in place using Heap's algorithm, and ends at the "last" permutation without being restored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>reentrant data to pass to the callback, can provide input, output, and persistant state without needing to hijack ft-&gt;base.data or similar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if an array of self-&gt;len uint64_t's cannot be allocated) </dd></dl>

</div>
</div>
<a id="a1eb0504e94b02093d2380b140106c109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb0504e94b02093d2380b140106c109">&#9670;&nbsp;</a></span>cr8r_bvec_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>src_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>src_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new bit vector by concatenating copies of two given bit vectors. </p>
<p>dest should NOT be initialized or its buffer will be leaked! First, ensures the dest buffer has enough capacity for both src bit vectors, extending if necessary, then copy the bit vectors one after the other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>bit vector in which to store result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_a,src_b</td><td>bit vectors to copy elements from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a096d7d815df770a1ac929bdd3877f308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096d7d815df770a1ac929bdd3877f308">&#9670;&nbsp;</a></span>cr8r_bvec_augment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_augment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a copy of another bit vector to a given bit vector. </p>
<p>First, extends self-&gt;buf if needed, then copy the other bit vector right after the current end. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>bit vector to extend with a copy of the other bit vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>bit vector to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a1e95fb921183150ace4bf19bd0df661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e95fb921183150ace4bf19bd0df661a">&#9670;&nbsp;</a></span>cr8r_bvec_set_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_bvec_set_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all bits in a range WITH bounds checking. </p>
<p>The bounds are [a, b) </p><dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (out of bounds) </dd></dl>

</div>
</div>
<a id="a4d5c1f4077c0f6cfe71a33b4cbe71c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5c1f4077c0f6cfe71a33b4cbe71c19">&#9670;&nbsp;</a></span>cr8r_bvec_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_bvec_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__bvec.html">cr8r_bvec</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographically compare two bit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>vectors to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if a is lexicographically before b, +1 visa versa, or 0 if they are equal </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acb1d85b06477aed27852b22bfe2a500e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1d85b06477aed27852b22bfe2a500e">&#9670;&nbsp;</a></span>cr8r_bvecft</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__bvec__ft.html">cr8r_bvec_ft</a> cr8r_bvecft</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function table for bit vectors. </p>
<p>The default allocation scheme <a class="el" href="container_8h.html#afe863262f21f39d2d95940863e10d883">cr8r_default_new_size</a> and <a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a> is used. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li><li class="navelem"><a class="el" href="bitvec_8h.html">bitvec.h</a></li>
    <li class="footer">Generated on Sat Apr 15 2023 07:48:51 for Crater Container Library by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
