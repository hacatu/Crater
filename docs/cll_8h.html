<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/cll.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crater Container Library
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cll.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="container_8h_source.html">crater/container.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="sla_8h_source.html">crater/sla.h</a>&gt;</code><br />
</div>
<p><a href="cll_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for linked list.  <a href="structcr8r__cll__ft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c3a3238e95b7e728096fa4dd5b8c724"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a0c3a3238e95b7e728096fa4dd5b8c724">cr8r_cll_node</a></td></tr>
<tr class="memdesc:a0c3a3238e95b7e728096fa4dd5b8c724"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular linked list node, or an entire circular linked list by synecdoche Note that a pointer to the LAST node is typically passed around, because last-&gt;next gets the first node.  <a href="cll_8h.html#a0c3a3238e95b7e728096fa4dd5b8c724">More...</a><br /></td></tr>
<tr class="separator:a0c3a3238e95b7e728096fa4dd5b8c724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada49d06b3137a31c52e97f38ff4f275a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#ada49d06b3137a31c52e97f38ff4f275a">cr8r_cll_ft_init</a> (<a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, void *data, uint64_t size, void *(*alloc)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *), void(*del)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *), void(*copy)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src), int(*cmp)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *))</td></tr>
<tr class="memdesc:ada49d06b3137a31c52e97f38ff4f275a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to initialize a <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a>.  <a href="cll_8h.html#ada49d06b3137a31c52e97f38ff4f275a">More...</a><br /></td></tr>
<tr class="separator:ada49d06b3137a31c52e97f38ff4f275a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4965c643199d16bd84fbc4bfc8b5e54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#ac4965c643199d16bd84fbc4bfc8b5e54">cr8r_cll_ft_initsla</a> (<a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, <a class="el" href="structcr8r__sla.html">cr8r_sla</a> *sla, uint64_t size, uint64_t reserve, void(*copy)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src), int(*cmp)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *))</td></tr>
<tr class="memdesc:ac4965c643199d16bd84fbc4bfc8b5e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to initialize a <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> and associated slab allocator.  <a href="cll_8h.html#ac4965c643199d16bd84fbc4bfc8b5e54">More...</a><br /></td></tr>
<tr class="separator:ac4965c643199d16bd84fbc4bfc8b5e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d4d42a2fa9354f703c5fd584dc9512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a08d4d42a2fa9354f703c5fd584dc9512">cr8r_cll_new</a> (<a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, const void *data)</td></tr>
<tr class="memdesc:a08d4d42a2fa9354f703c5fd584dc9512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new list node and initialize it with given data.  <a href="cll_8h.html#a08d4d42a2fa9354f703c5fd584dc9512">More...</a><br /></td></tr>
<tr class="separator:a08d4d42a2fa9354f703c5fd584dc9512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0205d5761f12ec19c066386fb1520259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a0205d5761f12ec19c066386fb1520259">cr8r_cll_delete</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:a0205d5761f12ec19c066386fb1520259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a list.  <a href="cll_8h.html#a0205d5761f12ec19c066386fb1520259">More...</a><br /></td></tr>
<tr class="separator:a0205d5761f12ec19c066386fb1520259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3788a15d6f6e1dbbc0e32e0c490639be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a3788a15d6f6e1dbbc0e32e0c490639be">cr8r_cll_copy</a> (const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:a3788a15d6f6e1dbbc0e32e0c490639be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a list.  <a href="cll_8h.html#a3788a15d6f6e1dbbc0e32e0c490639be">More...</a><br /></td></tr>
<tr class="separator:a3788a15d6f6e1dbbc0e32e0c490639be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf798668128551db618d37a7c49fe3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#abf798668128551db618d37a7c49fe3c9">cr8r_cll_from</a> (<a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, uint64_t len, const void *a)</td></tr>
<tr class="memdesc:abf798668128551db618d37a7c49fe3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list from an array.  <a href="cll_8h.html#abf798668128551db618d37a7c49fe3c9">More...</a><br /></td></tr>
<tr class="separator:abf798668128551db618d37a7c49fe3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc142ac560423c6dd6eda215719bec2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a9bc142ac560423c6dd6eda215719bec2">cr8r_cll_pushl</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, const void *val)</td></tr>
<tr class="memdesc:a9bc142ac560423c6dd6eda215719bec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node with a given value at the beginning of the list.  <a href="cll_8h.html#a9bc142ac560423c6dd6eda215719bec2">More...</a><br /></td></tr>
<tr class="separator:a9bc142ac560423c6dd6eda215719bec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e31829cf35826f2fe09ab3d7c2213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a6d2e31829cf35826f2fe09ab3d7c2213">cr8r_cll_popl</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, void *out)</td></tr>
<tr class="memdesc:a6d2e31829cf35826f2fe09ab3d7c2213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first node in the list.  <a href="cll_8h.html#a6d2e31829cf35826f2fe09ab3d7c2213">More...</a><br /></td></tr>
<tr class="separator:a6d2e31829cf35826f2fe09ab3d7c2213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f5ce1d3c1f71a915fbefe9989a413a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a00f5ce1d3c1f71a915fbefe9989a413a">cr8r_cll_pushr</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, const void *val)</td></tr>
<tr class="memdesc:a00f5ce1d3c1f71a915fbefe9989a413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node with a given value at the end of the list.  <a href="cll_8h.html#a00f5ce1d3c1f71a915fbefe9989a413a">More...</a><br /></td></tr>
<tr class="separator:a00f5ce1d3c1f71a915fbefe9989a413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08ada41e1ad33773d3ee999f40a4c1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#ad08ada41e1ad33773d3ee999f40a4c1a">cr8r_cll_popr</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, void *out)</td></tr>
<tr class="memdesc:ad08ada41e1ad33773d3ee999f40a4c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first node in the list.  <a href="cll_8h.html#ad08ada41e1ad33773d3ee999f40a4c1a">More...</a><br /></td></tr>
<tr class="separator:ad08ada41e1ad33773d3ee999f40a4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5131d23d34d7fd8c7401b4d9f2d287af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a5131d23d34d7fd8c7401b4d9f2d287af">cr8r_cll_filtered</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **dest, const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *src, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:a5131d23d34d7fd8c7401b4d9f2d287af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list from the subsequence of a given list satisfying a predicate.  <a href="cll_8h.html#a5131d23d34d7fd8c7401b4d9f2d287af">More...</a><br /></td></tr>
<tr class="separator:a5131d23d34d7fd8c7401b4d9f2d287af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4ff845a61055e6263c7da694dd6416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#aaf4ff845a61055e6263c7da694dd6416">cr8r_cll_filter</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:aaf4ff845a61055e6263c7da694dd6416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a list in place by deleting all nodes that don't match a predicate.  <a href="cll_8h.html#aaf4ff845a61055e6263c7da694dd6416">More...</a><br /></td></tr>
<tr class="separator:aaf4ff845a61055e6263c7da694dd6416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07718480edee51394bd0283c4ce468e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a07718480edee51394bd0283c4ce468e9">cr8r_cll_mapped</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **dest, const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *src, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *dest_ft, void(*f)(void *o, const void *e))</td></tr>
<tr class="memdesc:a07718480edee51394bd0283c4ce468e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list by applying a transformation function to every element in a list.  <a href="cll_8h.html#a07718480edee51394bd0283c4ce468e9">More...</a><br /></td></tr>
<tr class="separator:a07718480edee51394bd0283c4ce468e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab342c28e15723b7b7e3cc043ed341a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#ab342c28e15723b7b7e3cc043ed341a15">cr8r_cll_forEach</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, void(*f)(void *))</td></tr>
<tr class="memdesc:ab342c28e15723b7b7e3cc043ed341a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a given function on each element in a list.  <a href="cll_8h.html#ab342c28e15723b7b7e3cc043ed341a15">More...</a><br /></td></tr>
<tr class="separator:ab342c28e15723b7b7e3cc043ed341a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0274036f741d3f627d7290bbe408cfa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a0274036f741d3f627d7290bbe408cfa6">cr8r_cll_combine</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *a, <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *b, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:a0274036f741d3f627d7290bbe408cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stitch together two lists, one after the other.  <a href="cll_8h.html#a0274036f741d3f627d7290bbe408cfa6">More...</a><br /></td></tr>
<tr class="separator:a0274036f741d3f627d7290bbe408cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e4d16d9a864404e76306117d536dcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#aa0e4d16d9a864404e76306117d536dcb">cr8r_cll_all</a> (const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:aa0e4d16d9a864404e76306117d536dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a predicate holds for all elements in a list.  <a href="cll_8h.html#aa0e4d16d9a864404e76306117d536dcb">More...</a><br /></td></tr>
<tr class="separator:aa0e4d16d9a864404e76306117d536dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72049efaf13246dde412b80bca9f1e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#ab72049efaf13246dde412b80bca9f1e1">cr8r_cll_any</a> (const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:ab72049efaf13246dde412b80bca9f1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a predicate holds for any element in a list.  <a href="cll_8h.html#ab72049efaf13246dde412b80bca9f1e1">More...</a><br /></td></tr>
<tr class="separator:ab72049efaf13246dde412b80bca9f1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2450ff6e670d3a45506615174c106d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a2450ff6e670d3a45506615174c106d60">cr8r_cll_lsearch</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a2450ff6e670d3a45506615174c106d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node in a list with an element matching a given element according to ft-&gt;cmp.  <a href="cll_8h.html#a2450ff6e670d3a45506615174c106d60">More...</a><br /></td></tr>
<tr class="separator:a2450ff6e670d3a45506615174c106d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d29f8b4035dd8cdc381c87e6cea1e7b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a2d29f8b4035dd8cdc381c87e6cea1e7b">cr8r_cll_foldr</a> (const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *, void *init, void *(*f)(void *acc, const void *e))</td></tr>
<tr class="memdesc:a2d29f8b4035dd8cdc381c87e6cea1e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a right fold on a list.  <a href="cll_8h.html#a2d29f8b4035dd8cdc381c87e6cea1e7b">More...</a><br /></td></tr>
<tr class="separator:a2d29f8b4035dd8cdc381c87e6cea1e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfedd9fabed6feee11c8a2d98e66b4fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#acfedd9fabed6feee11c8a2d98e66b4fe">cr8r_cll_sort</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:acfedd9fabed6feee11c8a2d98e66b4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list in place.  <a href="cll_8h.html#acfedd9fabed6feee11c8a2d98e66b4fe">More...</a><br /></td></tr>
<tr class="separator:acfedd9fabed6feee11c8a2d98e66b4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d5cc36270cabcfd6cc4126932211e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a2a1d5cc36270cabcfd6cc4126932211e">cr8r_cll_sorted</a> (const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:a2a1d5cc36270cabcfd6cc4126932211e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sorted copy of a list.  <a href="cll_8h.html#a2a1d5cc36270cabcfd6cc4126932211e">More...</a><br /></td></tr>
<tr class="separator:a2a1d5cc36270cabcfd6cc4126932211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658cc3ace5ad33aa86412a828d6f2289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a658cc3ace5ad33aa86412a828d6f2289">cr8r_cll_reverse</a> (<a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **self, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:a658cc3ace5ad33aa86412a828d6f2289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a list in place.  <a href="cll_8h.html#a658cc3ace5ad33aa86412a828d6f2289">More...</a><br /></td></tr>
<tr class="separator:a658cc3ace5ad33aa86412a828d6f2289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1b95f04a0b136db3189b887e692396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cll_8h.html#a2e1b95f04a0b136db3189b887e692396">cr8r_cll_reversed</a> (const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *, <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *)</td></tr>
<tr class="memdesc:a2e1b95f04a0b136db3189b887e692396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reversed copy of a list.  <a href="cll_8h.html#a2e1b95f04a0b136db3189b887e692396">More...</a><br /></td></tr>
<tr class="separator:a2e1b95f04a0b136db3189b887e692396"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Simple generic singly linked list Remember that this is all fun and games, but a vector will generally be much faster for just about everything. </p>

<p class="definition">Definition in file <a class="el" href="cll_8h_source.html">cll.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0c3a3238e95b7e728096fa4dd5b8c724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3a3238e95b7e728096fa4dd5b8c724">&#9670;&nbsp;</a></span>cr8r_cll_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A circular linked list node, or an entire circular linked list by synecdoche Note that a pointer to the LAST node is typically passed around, because last-&gt;next gets the first node. </p>
<p>Take care if manipulating these fields directly, this should only be done if the functions in this file are not sufficient </p>

<p class="definition">Definition at line <a class="el" href="cll_8h_source.html#l00027">27</a> of file <a class="el" href="cll_8h_source.html">cll.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada49d06b3137a31c52e97f38ff4f275a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada49d06b3137a31c52e97f38ff4f275a">&#9670;&nbsp;</a></span>cr8r_cll_ft_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_ft_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *)&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *)&#160;</td>
          <td class="paramname"><em>del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src)&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to initialize a <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a>. </p>
<p>Using standard structure initializer syntax with designated initializers may be simpler. However, this function provides basic checking (it checks the required functions aren't NULL). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to user defined data to associate with the function table. generally NULL is sufficient. see <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> for a more in-depth explaination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single element in bytes. Note that the size of a node will be offsetof(cr8r_cll_node, data) + size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocate a single node. Using a slab allocator ( <a class="el" href="structcr8r__sla.html">cr8r_sla</a> ) is a good choice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>free a single node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>copy an element. can be NULL if memcpy is sufficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparison function. must not be NULL in order to call any searching or sorting functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if alloc or del is NULL) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00008">8</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="ac4965c643199d16bd84fbc4bfc8b5e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4965c643199d16bd84fbc4bfc8b5e54">&#9670;&nbsp;</a></span>cr8r_cll_ft_initsla()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_ft_initsla </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__sla.html">cr8r_sla</a> *&#160;</td>
          <td class="paramname"><em>sla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>reserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src)&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to initialize a <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> and associated slab allocator. </p>
<p>Automatically initializes sla, points ft-&gt;base.data at sla, and sets ft-&gt;alloc and ft-&gt;free to <a class="el" href="container_8h.html#a67139601d9563b33acd69ec924eedfd3">cr8r_default_alloc_sla</a> and <a class="el" href="container_8h.html#a626e88c5f0d4d62a4d09d90df419a2c3">cr8r_default_free_sla</a> respectively. WARNING sla is always initialized, an initialized sla should not be passed and in particular to make multiple tables with the same slab allocator, call this once and then call <a class="el" href="cll_8h.html#ada49d06b3137a31c52e97f38ff4f275a">cr8r_cll_ft_init</a> or use a literal for subsequent function tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sla</td><td>slab allocator to initialize and point ft-&gt;base.data at. must be uninitialized. it is possible to have more information in ft-&gt;base.data by placing sla in a structure and additional information before or after it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single element (of the circular list) in bytes. the size of a node (or slab allocator element) is offsetof(cr8r_cll_node, data) + size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reserve</td><td>how many nodes to reserve space for in the slab allocator initially. must not be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>copy an element. can be NULL if memcpy is sufficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparison function. should not be NULL. some functions do not require it, but it is required to do anything useful with avl trees. See <a class="el" href="container_8h.html#adb4b61e520c0cee3c3d074635d6cdef4">cr8r_default_cmp</a> for a basic generic implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if cmp, sla, or reserve is NULL/0 or the slab allocator cannot reserve enough memory) </dd></dl>

</div>
</div>
<a id="a08d4d42a2fa9354f703c5fd584dc9512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d4d42a2fa9354f703c5fd584dc9512">&#9670;&nbsp;</a></span>cr8r_cll_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new list node and initialize it with given data. </p>
<p>The next field in the created node points to itself, as a singleton circular linked list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>element to put into the node. This is generally a structure with conceptual "key" and "value" parts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new, initialized node, or NULL if ft-&gt;alloc fails. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00045">45</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a0205d5761f12ec19c066386fb1520259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0205d5761f12ec19c066386fb1520259">&#9670;&nbsp;</a></span>cr8r_cll_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_cll_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a list. </p>
<p>Calls ft-&gt;del on each node </p>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00054">54</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a3788a15d6f6e1dbbc0e32e0c490639be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3788a15d6f6e1dbbc0e32e0c490639be">&#9670;&nbsp;</a></span>cr8r_cll_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a list. </p>
<p>Copies entries with ft-&gt;copy if applicable. </p><dl class="section return"><dt>Returns</dt><dd>pointer to a copy of the list on success, or NULL if ft-&gt;alloc fails. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00066">66</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="abf798668128551db618d37a7c49fe3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf798668128551db618d37a7c49fe3c9">&#9670;&nbsp;</a></span>cr8r_cll_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list from an array. </p>
<p>Copies entries with ft-&gt;copy if applicable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the beginning of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a list copied from the array on success, or NULL if ft-&gt;alloc fails. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00093">93</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a9bc142ac560423c6dd6eda215719bec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc142ac560423c6dd6eda215719bec2">&#9670;&nbsp;</a></span>cr8r_cll_pushl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_pushl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node with a given value at the beginning of the list. </p>
<p>This is an O(1) operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>pointer to pointer to last node in current list, so that if the last node changes (ie if inserting into a NULL list) it can be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to add to the list. ft-&gt;alloc is called to create the node to place it in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00116">116</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a6d2e31829cf35826f2fe09ab3d7c2213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2e31829cf35826f2fe09ab3d7c2213">&#9670;&nbsp;</a></span>cr8r_cll_popl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_popl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first node in the list. </p>
<p>This is an O(1) operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>pointer to pointer to last node in current list, so that if the last node changes (ie if removing from a singleton list) it can be updated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the element of the removed node is copied here and then the removed node is deallocated with ft-&gt;del </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if *self is NULL corresponding to removing from a NULL list) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00125">125</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a00f5ce1d3c1f71a915fbefe9989a413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f5ce1d3c1f71a915fbefe9989a413a">&#9670;&nbsp;</a></span>cr8r_cll_pushr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_pushr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node with a given value at the end of the list. </p>
<p>This is an O(1) operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>pointer to pointer to last node in current list, so it can be updated because this operation always changes it to the new node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to add to the list. ft-&gt;alloc is called to create the node to place it in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00140">140</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="ad08ada41e1ad33773d3ee999f40a4c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08ada41e1ad33773d3ee999f40a4c1a">&#9670;&nbsp;</a></span>cr8r_cll_popr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_popr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first node in the list. </p>
<p>This is an O(n) operation. Using a circular linked list allows us to go from having just pushl and popl be constant time to pushr as well, but to get constant time popr a doubly linked list (including XOR or offset lists) is needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>pointer to pointer to last node in current list, so that it can be updated because this operation always changes it to the previous node unless the list is a single or empty, in which case this is set to NULL or the operation fails, respectively. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the element of the removed node is copied here and then the removed node is deallocated with ft-&gt;del </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if *self is NULL corresponding to removing from a NULL list) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00150">150</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a5131d23d34d7fd8c7401b4d9f2d287af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5131d23d34d7fd8c7401b4d9f2d287af">&#9670;&nbsp;</a></span>cr8r_cll_filtered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list from the subsequence of a given list satisfying a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to store filtered list in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>list to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on all elements of the input list. elements for which 1 is returned are copied to the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, or 0 on allocation failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00165">165</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="aaf4ff845a61055e6263c7da694dd6416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4ff845a61055e6263c7da694dd6416">&#9670;&nbsp;</a></span>cr8r_cll_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_cll_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a list in place by deleting all nodes that don't match a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>pointer to pointer to last element of list to filter, so that it can be updated if it changes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on all elements of the input list. elements for which 0 is returned are removed and deleted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00198">198</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a07718480edee51394bd0283c4ce468e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07718480edee51394bd0283c4ce468e9">&#9670;&nbsp;</a></span>cr8r_cll_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_mapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname"><em>dest_ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *o, const void *e)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list by applying a transformation function to every element in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>pointer to store map output list in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>list to map from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_ft</td><td>function table <a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>transformation function, called on all elements of the input list to produce elements of output list. the first argument is a pointer to the output list element to populate, and the second argument is a pointer to the input list element to map from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on allocation failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00216">216</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="ab342c28e15723b7b7e3cc043ed341a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab342c28e15723b7b7e3cc043ed341a15">&#9670;&nbsp;</a></span>cr8r_cll_forEach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_cll_forEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a given function on each element in a list. </p>
<p>Processes elements in order starting with the first Only useful for dirty, dirty side effects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00237">237</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a0274036f741d3f627d7290bbe408cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0274036f741d3f627d7290bbe408cfa6">&#9670;&nbsp;</a></span>cr8r_cll_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stitch together two lists, one after the other. </p>
<p>Given two lists, connects them to form a longer list. Updates a-&gt;next, b-&gt;next = b, a-&gt;next and returns b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>pointer to the last element of the first list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>pointer to the last element of the second list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the last element of the combined list, namely b </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00249">249</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="aa0e4d16d9a864404e76306117d536dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e4d16d9a864404e76306117d536dcb">&#9670;&nbsp;</a></span>cr8r_cll_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a predicate holds for all elements in a list. </p>
<p>Returns false immediately if any element does not satisfy the predicate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>list to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on each element in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the predicate function returns 1 on all elements, 0 (as soon as it doesn't) otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00261">261</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="ab72049efaf13246dde412b80bca9f1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72049efaf13246dde412b80bca9f1e1">&#9670;&nbsp;</a></span>cr8r_cll_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_cll_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a predicate holds for any element in a list. </p>
<p>Returns true immediately if any element satisfies the predicate. Note that this is completely equivalent to the negation of <a class="el" href="cll_8h.html#aa0e4d16d9a864404e76306117d536dcb">cr8r_cll_all</a> with the negation of the predicate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on each element in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 (as soon as) the predicate function returns 1 on any element, 0 if it returns 0 on all of them </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00275">275</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a2450ff6e670d3a45506615174c106d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2450ff6e670d3a45506615174c106d60">&#9670;&nbsp;</a></span>cr8r_cll_lsearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_lsearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first node in a list with an element matching a given element according to ft-&gt;cmp. </p>
<p>This is O(n) because it simply does a linear search. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first node matching the given element, or NULL if none matches </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00289">289</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a2d29f8b4035dd8cdc381c87e6cea1e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d29f8b4035dd8cdc381c87e6cea1e7b">&#9670;&nbsp;</a></span>cr8r_cll_foldr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_cll_foldr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *acc, const void *e)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a right fold on a list. </p>
<p>Given an initial accumulator value of some type T in a void pointer, a list, and a function f that takes a void pointer to a T value and an element of the list and returns a void pointer to a T value, this function repeatedly applies f to the current accumulator and element to get the new accumulator value. This is repeated for every element in the left, going from left to right, and the final accumulator value is returned. The accumulation function f must handle freeing old accumulator values once it is finished with them if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>starting value for the accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>accumulation function: should take current accumulator value (as void pointer) and current list element and return new accumulator value. It should either modify the accumulator value in place, returning it as well, or allocate a new pointer for the new accumulator value and free the old one once the new one has been computed. In cases where the accumulator value is an integer or something else that fits within a pointer, the pointer can be used as a casted integer or whatnot instead of as a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final accumulator value </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00303">303</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="acfedd9fabed6feee11c8a2d98e66b4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfedd9fabed6feee11c8a2d98e66b4fe">&#9670;&nbsp;</a></span>cr8r_cll_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_cll_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a list in place. </p>
<p>Uses a merge sort like algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>pointer to pointer to last node in list. updated to contain a pointer to the new last node in case it changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a1d5cc36270cabcfd6cc4126932211e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d5cc36270cabcfd6cc4126932211e">&#9670;&nbsp;</a></span>cr8r_cll_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_sorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sorted copy of a list. </p>
<p>Simply calls <a class="el" href="cll_8h.html#a3788a15d6f6e1dbbc0e32e0c490639be">cr8r_cll_copy</a> and then <a class="el" href="cll_8h.html#acfedd9fabed6feee11c8a2d98e66b4fe">cr8r_cll_sort</a> on the copy </p><dl class="section return"><dt>Returns</dt><dd>pointer to the last element of the sorted copy, or NULL on an allocation failure Note that NULL is also returned if the input list is empty, but these reasons for returning NULL are mutually exclusive </dd></dl>

</div>
</div>
<a id="a658cc3ace5ad33aa86412a828d6f2289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658cc3ace5ad33aa86412a828d6f2289">&#9670;&nbsp;</a></span>cr8r_cll_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_cll_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> **&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse a list in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the list to reverse. passed as a pointer to a pointer to the last node, so that the pointer to the last node can be updated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00319">319</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
<a id="a2e1b95f04a0b136db3189b887e692396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1b95f04a0b136db3189b887e692396">&#9670;&nbsp;</a></span>cr8r_cll_reversed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a>* cr8r_cll_reversed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__cll__node.html">cr8r_cll_node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__cll__ft.html">cr8r_cll_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a reversed copy of a list. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the last element of the reversed copy, or NULL on an allocation failure Note that NULL is also returned if the input list is empty, but these reasons for returning NULL are mutually exclusive </dd></dl>

<p class="definition">Definition at line <a class="el" href="cll_8c_source.html#l00338">338</a> of file <a class="el" href="cll_8c_source.html">cll.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
