<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/vec.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Crater/index.html">Crater Container Library</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vec_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vec.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 Simple, featureful generic vector</dd></dl>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>

<p class="definition">Definition in file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>
</div>
<p><a href="vec_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__vec.html">cr8r_vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector Take care if manipulating these fields directly, this should only be done if the functions in this file are not sufficient.  <a href="structcr8r__vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for vector.  <a href="structcr8r__vec__ft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae19151b47a533be8fb62ee9b816d4007"><td class="memItemLeft" align="right" valign="top"><a id="ae19151b47a533be8fb62ee9b816d4007"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae19151b47a533be8fb62ee9b816d4007">CR8R_VEC_ISORT_BOUND</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ae19151b47a533be8fb62ee9b816d4007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold below which quicksort and quickselect will switch to using insertion sort. <br /></td></tr>
<tr class="separator:ae19151b47a533be8fb62ee9b816d4007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a904e79eacb27da124a159e60072cf285"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a>) (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *ent, void *data)</td></tr>
<tr class="memdesc:a904e79eacb27da124a159e60072cf285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for predicates on vector elements.  <a href="vec_8h.html#a904e79eacb27da124a159e60072cf285">More...</a><br /></td></tr>
<tr class="separator:a904e79eacb27da124a159e60072cf285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d44e1ee8740a1c6f03a15a9c64ce768"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a6d44e1ee8740a1c6f03a15a9c64ce768">cr8r_vec_mapper</a>) (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *src_ft, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *dest_ft, void *o, const void *e, void *data)</td></tr>
<tr class="memdesc:a6d44e1ee8740a1c6f03a15a9c64ce768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for functions mapping from one vector element type to another.  <a href="vec_8h.html#a6d44e1ee8740a1c6f03a15a9c64ce768">More...</a><br /></td></tr>
<tr class="separator:a6d44e1ee8740a1c6f03a15a9c64ce768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be8fd88d43867adc92c5de2a2e05cb7"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a8be8fd88d43867adc92c5de2a2e05cb7">cr8r_vec_accumulator</a>) (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *acc, const void *e)</td></tr>
<tr class="memdesc:a8be8fd88d43867adc92c5de2a2e05cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for accumulator functions on vectors (<a class="el" href="vec_8h.html#af519fece878d20ddc1c33daa4813aec9">cr8r_vec_foldl</a>)  <a href="vec_8h.html#a8be8fd88d43867adc92c5de2a2e05cb7">More...</a><br /></td></tr>
<tr class="separator:a8be8fd88d43867adc92c5de2a2e05cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8e5763aebc27e32c2913a674828e007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa8e5763aebc27e32c2913a674828e007">cr8r_vec_ft_init</a> (<a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *data, uint64_t size, uint64_t(*new_size)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, uint64_t cap), void *(*resize)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p, uint64_t cap), void(*del)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p), void(*copy)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src), int(*cmp)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *a, const void *b), void(*swap)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *a, void *b))</td></tr>
<tr class="memdesc:aa8e5763aebc27e32c2913a674828e007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to initialize a <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>.  <a href="vec_8h.html#aa8e5763aebc27e32c2913a674828e007">More...</a><br /></td></tr>
<tr class="separator:aa8e5763aebc27e32c2913a674828e007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8cd0da55cbed50ba9a46811a807582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a5d8cd0da55cbed50ba9a46811a807582">cr8r_vec_init</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t cap)</td></tr>
<tr class="memdesc:a5d8cd0da55cbed50ba9a46811a807582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a vector with an empty buffer of a given capacity.  <a href="vec_8h.html#a5d8cd0da55cbed50ba9a46811a807582">More...</a><br /></td></tr>
<tr class="separator:a5d8cd0da55cbed50ba9a46811a807582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb6c45cb315fe0582c59c53427bb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aaddb6c45cb315fe0582c59c53427bb1a">cr8r_vec_delete</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:aaddb6c45cb315fe0582c59c53427bb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all entries in a vector and free its buffer.  <a href="vec_8h.html#aaddb6c45cb315fe0582c59c53427bb1a">More...</a><br /></td></tr>
<tr class="separator:aaddb6c45cb315fe0582c59c53427bb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7f642d154e92357ef970feb3e5c138"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#adf7f642d154e92357ef970feb3e5c138">cr8r_vec_copy</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:adf7f642d154e92357ef970feb3e5c138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a vector.  <a href="vec_8h.html#adf7f642d154e92357ef970feb3e5c138">More...</a><br /></td></tr>
<tr class="separator:adf7f642d154e92357ef970feb3e5c138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad967b976465b0055a5b89bfb8cd07bbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad967b976465b0055a5b89bfb8cd07bbe">cr8r_vec_sub</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:ad967b976465b0055a5b89bfb8cd07bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a slice of a vector.  <a href="vec_8h.html#ad967b976465b0055a5b89bfb8cd07bbe">More...</a><br /></td></tr>
<tr class="separator:ad967b976465b0055a5b89bfb8cd07bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2619b3844488731f3361d09ad76ef855"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a2619b3844488731f3361d09ad76ef855">cr8r_vec_resize</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t cap)</td></tr>
<tr class="memdesc:a2619b3844488731f3361d09ad76ef855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a vector's reserved buffer.  <a href="vec_8h.html#a2619b3844488731f3361d09ad76ef855">More...</a><br /></td></tr>
<tr class="separator:a2619b3844488731f3361d09ad76ef855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6c53aa17d83328eda34a5d1a94e3ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#adc6c53aa17d83328eda34a5d1a94e3ba">cr8r_vec_trim</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:adc6c53aa17d83328eda34a5d1a94e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a vector's reserved buffer to its length.  <a href="vec_8h.html#adc6c53aa17d83328eda34a5d1a94e3ba">More...</a><br /></td></tr>
<tr class="separator:adc6c53aa17d83328eda34a5d1a94e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac836b7eb6db947abf22dd5e69694814f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ac836b7eb6db947abf22dd5e69694814f">cr8r_vec_clear</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ac836b7eb6db947abf22dd5e69694814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from a vector.  <a href="vec_8h.html#ac836b7eb6db947abf22dd5e69694814f">More...</a><br /></td></tr>
<tr class="separator:ac836b7eb6db947abf22dd5e69694814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b6dcca4bdbc7caf7df8a78525c3ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa4b6dcca4bdbc7caf7df8a78525c3ef0">cr8r_vec_shuffle</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:aa4b6dcca4bdbc7caf7df8a78525c3ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the vector into a random permutation.  <a href="vec_8h.html#aa4b6dcca4bdbc7caf7df8a78525c3ef0">More...</a><br /></td></tr>
<tr class="separator:aa4b6dcca4bdbc7caf7df8a78525c3ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7f424dd3f0a87649bf94995900b6c8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aca7f424dd3f0a87649bf94995900b6c8">cr8r_vec_get</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t i)</td></tr>
<tr class="memdesc:aca7f424dd3f0a87649bf94995900b6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at a given index.  <a href="vec_8h.html#aca7f424dd3f0a87649bf94995900b6c8">More...</a><br /></td></tr>
<tr class="separator:aca7f424dd3f0a87649bf94995900b6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeda529e2562f99f42c1044e217cc70"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aabeda529e2562f99f42c1044e217cc70">cr8r_vec_getx</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, int64_t i)</td></tr>
<tr class="memdesc:aabeda529e2562f99f42c1044e217cc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at a given index, with support for negative indices.  <a href="vec_8h.html#aabeda529e2562f99f42c1044e217cc70">More...</a><br /></td></tr>
<tr class="separator:aabeda529e2562f99f42c1044e217cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aefad9c344d8c7d9a25b236d813312"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa2aefad9c344d8c7d9a25b236d813312">cr8r_vec_len</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *)</td></tr>
<tr class="memdesc:aa2aefad9c344d8c7d9a25b236d813312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a vector.  <a href="vec_8h.html#aa2aefad9c344d8c7d9a25b236d813312">More...</a><br /></td></tr>
<tr class="separator:aa2aefad9c344d8c7d9a25b236d813312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136fc6242ac747df5f8bfa71bfd7e70d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a136fc6242ac747df5f8bfa71bfd7e70d">cr8r_vec_pushr</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a136fc6242ac747df5f8bfa71bfd7e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the right hand end of a vector.  <a href="vec_8h.html#a136fc6242ac747df5f8bfa71bfd7e70d">More...</a><br /></td></tr>
<tr class="separator:a136fc6242ac747df5f8bfa71bfd7e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599c09159cb69c595de1aff43ee10b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a599c09159cb69c595de1aff43ee10b83">cr8r_vec_popr</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *o)</td></tr>
<tr class="memdesc:a599c09159cb69c595de1aff43ee10b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the right hand end of a vector.  <a href="vec_8h.html#a599c09159cb69c595de1aff43ee10b83">More...</a><br /></td></tr>
<tr class="separator:a599c09159cb69c595de1aff43ee10b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26bf98f8cc996edc8a3fe5560cd6353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ac26bf98f8cc996edc8a3fe5560cd6353">cr8r_vec_pushl</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:ac26bf98f8cc996edc8a3fe5560cd6353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the left hand end of a vector.  <a href="vec_8h.html#ac26bf98f8cc996edc8a3fe5560cd6353">More...</a><br /></td></tr>
<tr class="separator:ac26bf98f8cc996edc8a3fe5560cd6353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e46add615e3db6087de21050005522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad1e46add615e3db6087de21050005522">cr8r_vec_popl</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *o)</td></tr>
<tr class="memdesc:ad1e46add615e3db6087de21050005522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the left hand end of a vector.  <a href="vec_8h.html#ad1e46add615e3db6087de21050005522">More...</a><br /></td></tr>
<tr class="separator:ad1e46add615e3db6087de21050005522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375928e0d906305237207ce0426b2486"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a375928e0d906305237207ce0426b2486">cr8r_vec_filter</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a> pred, void *data)</td></tr>
<tr class="memdesc:a375928e0d906305237207ce0426b2486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a vector in-place.  <a href="vec_8h.html#a375928e0d906305237207ce0426b2486">More...</a><br /></td></tr>
<tr class="separator:a375928e0d906305237207ce0426b2486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561c4ce5c4e2255ed4eeaa1bb3581ff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a561c4ce5c4e2255ed4eeaa1bb3581ff6">cr8r_vec_filtered</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a> pred, void *data)</td></tr>
<tr class="memdesc:a561c4ce5c4e2255ed4eeaa1bb3581ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector as a subsequence matching a predicate.  <a href="vec_8h.html#a561c4ce5c4e2255ed4eeaa1bb3581ff6">More...</a><br /></td></tr>
<tr class="separator:a561c4ce5c4e2255ed4eeaa1bb3581ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d099a5ea84cb4085c5ec194a59ec52f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a7d099a5ea84cb4085c5ec194a59ec52f">cr8r_vec_map</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *src_ft, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *dest_ft, <a class="el" href="vec_8h.html#a6d44e1ee8740a1c6f03a15a9c64ce768">cr8r_vec_mapper</a> f, void *data)</td></tr>
<tr class="memdesc:a7d099a5ea84cb4085c5ec194a59ec52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector by applying a transformation function to each element.  <a href="vec_8h.html#a7d099a5ea84cb4085c5ec194a59ec52f">More...</a><br /></td></tr>
<tr class="separator:a7d099a5ea84cb4085c5ec194a59ec52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e787957cf8bb14c7a6d60061af07173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a7e787957cf8bb14c7a6d60061af07173">cr8r_vec_forEachPermutation</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void(*f)(const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *data), void *data)</td></tr>
<tr class="memdesc:a7e787957cf8bb14c7a6d60061af07173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on every permutation of a vector.  <a href="vec_8h.html#a7e787957cf8bb14c7a6d60061af07173">More...</a><br /></td></tr>
<tr class="separator:a7e787957cf8bb14c7a6d60061af07173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307ce32661ae90e4b3d5d751f9cea3ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a307ce32661ae90e4b3d5d751f9cea3ba">cr8r_vec_combine</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src_a, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src_b, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a307ce32661ae90e4b3d5d751f9cea3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector by concatenating copies of two given vectors.  <a href="vec_8h.html#a307ce32661ae90e4b3d5d751f9cea3ba">More...</a><br /></td></tr>
<tr class="separator:a307ce32661ae90e4b3d5d751f9cea3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d51bc905d119424b59a57b6973041f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a5d51bc905d119424b59a57b6973041f5">cr8r_vec_augment</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *self, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *other, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a5d51bc905d119424b59a57b6973041f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a copy of another vector to a given vector.  <a href="vec_8h.html#a5d51bc905d119424b59a57b6973041f5">More...</a><br /></td></tr>
<tr class="separator:a5d51bc905d119424b59a57b6973041f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09f92dfd14711cb40908e76b826389a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa09f92dfd14711cb40908e76b826389a">cr8r_vec_all</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a> pred, void *data)</td></tr>
<tr class="memdesc:aa09f92dfd14711cb40908e76b826389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a predicate holds for all elements in a vector.  <a href="vec_8h.html#aa09f92dfd14711cb40908e76b826389a">More...</a><br /></td></tr>
<tr class="separator:aa09f92dfd14711cb40908e76b826389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051014ce44ee03d1f38e9bec0be0dfb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a051014ce44ee03d1f38e9bec0be0dfb3">cr8r_vec_any</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a> pred, void *data)</td></tr>
<tr class="memdesc:a051014ce44ee03d1f38e9bec0be0dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a predicate holds for any element in a vector.  <a href="vec_8h.html#a051014ce44ee03d1f38e9bec0be0dfb3">More...</a><br /></td></tr>
<tr class="separator:a051014ce44ee03d1f38e9bec0be0dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c46fe63b3e84780b58260594e79a30a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a6c46fe63b3e84780b58260594e79a30a">cr8r_vec_contains</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a6c46fe63b3e84780b58260594e79a30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a vector contains a given element.  <a href="vec_8h.html#a6c46fe63b3e84780b58260594e79a30a">More...</a><br /></td></tr>
<tr class="separator:a6c46fe63b3e84780b58260594e79a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b32323f2ef92ca85694161725826e97"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a3b32323f2ef92ca85694161725826e97">cr8r_vec_index</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a3b32323f2ef92ca85694161725826e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of an element in a vector.  <a href="vec_8h.html#a3b32323f2ef92ca85694161725826e97">More...</a><br /></td></tr>
<tr class="separator:a3b32323f2ef92ca85694161725826e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132b16ba4b1de994c74a4ef8762a0224"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a132b16ba4b1de994c74a4ef8762a0224">cr8r_vec_exm</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, int ord)</td></tr>
<tr class="memdesc:a132b16ba4b1de994c74a4ef8762a0224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the extremal (minimum or maximum) element of a vector.  <a href="vec_8h.html#a132b16ba4b1de994c74a4ef8762a0224">More...</a><br /></td></tr>
<tr class="separator:a132b16ba4b1de994c74a4ef8762a0224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac300459e0111780316db62fc1aa54d4c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">cr8r_vec_foldr</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="vec_8h.html#a8be8fd88d43867adc92c5de2a2e05cb7">cr8r_vec_accumulator</a> f, void *init)</td></tr>
<tr class="memdesc:ac300459e0111780316db62fc1aa54d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a right fold on a vector.  <a href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">More...</a><br /></td></tr>
<tr class="separator:ac300459e0111780316db62fc1aa54d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519fece878d20ddc1c33daa4813aec9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#af519fece878d20ddc1c33daa4813aec9">cr8r_vec_foldl</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="vec_8h.html#a8be8fd88d43867adc92c5de2a2e05cb7">cr8r_vec_accumulator</a> f, void *init)</td></tr>
<tr class="memdesc:af519fece878d20ddc1c33daa4813aec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold on a vector.  <a href="vec_8h.html#af519fece878d20ddc1c33daa4813aec9">More...</a><br /></td></tr>
<tr class="separator:af519fece878d20ddc1c33daa4813aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcbace693b2aa77a48b55291d74ad4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a9bcbace693b2aa77a48b55291d74ad4f">cr8r_vec_sort</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a9bcbace693b2aa77a48b55291d74ad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a vector in-place according to ft-&gt;cmp.  <a href="vec_8h.html#a9bcbace693b2aa77a48b55291d74ad4f">More...</a><br /></td></tr>
<tr class="separator:a9bcbace693b2aa77a48b55291d74ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21dbfd3a9e07c60aeaade8c795e252c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae21dbfd3a9e07c60aeaade8c795e252c">cr8r_vec_sorted</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ae21dbfd3a9e07c60aeaade8c795e252c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sorted copy of a vector.  <a href="vec_8h.html#ae21dbfd3a9e07c60aeaade8c795e252c">More...</a><br /></td></tr>
<tr class="separator:ae21dbfd3a9e07c60aeaade8c795e252c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086baaf5b286b06c10ba63a9bc41244e"><td class="memItemLeft" align="right" valign="top"><a id="a086baaf5b286b06c10ba63a9bc41244e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a086baaf5b286b06c10ba63a9bc41244e">cr8r_vec_reverse</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a086baaf5b286b06c10ba63a9bc41244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a vector in place. <br /></td></tr>
<tr class="separator:a086baaf5b286b06c10ba63a9bc41244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f8d8acbaa9e05a05deb6173fb203ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae6f8d8acbaa9e05a05deb6173fb203ae">cr8r_vec_reversed</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ae6f8d8acbaa9e05a05deb6173fb203ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reversed copy of a vector.  <a href="vec_8h.html#ae6f8d8acbaa9e05a05deb6173fb203ae">More...</a><br /></td></tr>
<tr class="separator:ae6f8d8acbaa9e05a05deb6173fb203ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee6e47feb7b49bf85b42d29acc41240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aeee6e47feb7b49bf85b42d29acc41240">cr8r_vec_containss</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:aeee6e47feb7b49bf85b42d29acc41240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a sorted vector contains an element.  <a href="vec_8h.html#aeee6e47feb7b49bf85b42d29acc41240">More...</a><br /></td></tr>
<tr class="separator:aeee6e47feb7b49bf85b42d29acc41240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9591ba11330afa82d760d0ad111d410"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae9591ba11330afa82d760d0ad111d410">cr8r_vec_indexs</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:ae9591ba11330afa82d760d0ad111d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of an element in a sorted vector.  <a href="vec_8h.html#ae9591ba11330afa82d760d0ad111d410">More...</a><br /></td></tr>
<tr class="separator:ae9591ba11330afa82d760d0ad111d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b70ed397697cecf35ff74c2f8a0b7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ab4b70ed397697cecf35ff74c2f8a0b7d">cr8r_vec_cmp</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *a, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *b, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ab4b70ed397697cecf35ff74c2f8a0b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compare two vectors.  <a href="vec_8h.html#ab4b70ed397697cecf35ff74c2f8a0b7d">More...</a><br /></td></tr>
<tr class="separator:ab4b70ed397697cecf35ff74c2f8a0b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eb8c7f28d1a6f930ef725634050d57"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a31eb8c7f28d1a6f930ef725634050d57">cr8r_vec_pivot_m3</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a31eb8c7f28d1a6f930ef725634050d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a pivot for <a class="el" href="vec_8h.html#ac1aab02695f085893fbfbe7f5ad7b476">cr8r_vec_partition</a> using the median of 3 approach.  <a href="vec_8h.html#a31eb8c7f28d1a6f930ef725634050d57">More...</a><br /></td></tr>
<tr class="separator:a31eb8c7f28d1a6f930ef725634050d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb20ca700c0e4d90dc5c649b4844f5c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a4cb20ca700c0e4d90dc5c649b4844f5c">cr8r_vec_pivot_mm</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a4cb20ca700c0e4d90dc5c649b4844f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a pivot for <a class="el" href="vec_8h.html#ac1aab02695f085893fbfbe7f5ad7b476">cr8r_vec_partition</a> using the median of medians approach.  <a href="vec_8h.html#a4cb20ca700c0e4d90dc5c649b4844f5c">More...</a><br /></td></tr>
<tr class="separator:a4cb20ca700c0e4d90dc5c649b4844f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aab02695f085893fbfbe7f5ad7b476"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ac1aab02695f085893fbfbe7f5ad7b476">cr8r_vec_partition</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b, void *piv)</td></tr>
<tr class="memdesc:ac1aab02695f085893fbfbe7f5ad7b476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a subrange of a vector into elements &lt; a pivot and elements &gt;= a pivot.  <a href="vec_8h.html#ac1aab02695f085893fbfbe7f5ad7b476">More...</a><br /></td></tr>
<tr class="separator:ac1aab02695f085893fbfbe7f5ad7b476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91efeb6db8a8931cb0ae2598ebf1125"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad91efeb6db8a8931cb0ae2598ebf1125">cr8r_vec_partition_with_median</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b, void *piv)</td></tr>
<tr class="memdesc:ad91efeb6db8a8931cb0ae2598ebf1125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a subrange of a vector into elements &lt;, ==, and &gt; a pivot.  <a href="vec_8h.html#ad91efeb6db8a8931cb0ae2598ebf1125">More...</a><br /></td></tr>
<tr class="separator:ad91efeb6db8a8931cb0ae2598ebf1125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e0c1ec199b4f22f35722da8e379707"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#af5e0c1ec199b4f22f35722da8e379707">cr8r_vec_ith</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b, uint64_t i)</td></tr>
<tr class="memdesc:af5e0c1ec199b4f22f35722da8e379707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the ith element of a subrange of a vector without completely sorting it.  <a href="vec_8h.html#af5e0c1ec199b4f22f35722da8e379707">More...</a><br /></td></tr>
<tr class="separator:af5e0c1ec199b4f22f35722da8e379707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b302c782e6b375225feb30bbc371cfd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a9b302c782e6b375225feb30bbc371cfd">cr8r_default_acc_sum_u64</a> (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *acc, const void *ent)</td></tr>
<tr class="memdesc:a9b302c782e6b375225feb30bbc371cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">cr8r_vec_foldr</a> to sum up elements in vector.  <a href="vec_8h.html#a9b302c782e6b375225feb30bbc371cfd">More...</a><br /></td></tr>
<tr class="separator:a9b302c782e6b375225feb30bbc371cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af164e28b1cf34667ea868a3a05348695"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#af164e28b1cf34667ea868a3a05348695">cr8r_default_acc_sumpowmod_u64</a> (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *acc, const void *ent)</td></tr>
<tr class="memdesc:af164e28b1cf34667ea868a3a05348695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">cr8r_vec_foldr</a> to sum up powers of elements in a vector mod a number.  <a href="vec_8h.html#af164e28b1cf34667ea868a3a05348695">More...</a><br /></td></tr>
<tr class="separator:af164e28b1cf34667ea868a3a05348695"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab7772f368e5b8af85b466188fbf941e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ab7772f368e5b8af85b466188fbf941e3">cr8r_vecft_u64</a></td></tr>
<tr class="memdesc:ab7772f368e5b8af85b466188fbf941e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for vectors of uint64_t's.  <a href="vec_8h.html#ab7772f368e5b8af85b466188fbf941e3">More...</a><br /></td></tr>
<tr class="separator:ab7772f368e5b8af85b466188fbf941e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af026cd1e578946255a90070d80d4b507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#af026cd1e578946255a90070d80d4b507">cr8r_vecft_cstr</a></td></tr>
<tr class="memdesc:af026cd1e578946255a90070d80d4b507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for vectors of strings.  <a href="vec_8h.html#af026cd1e578946255a90070d80d4b507">More...</a><br /></td></tr>
<tr class="separator:af026cd1e578946255a90070d80d4b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac67a3386892ea9daaa3974da649297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a6ac67a3386892ea9daaa3974da649297">cr8r_vecft_u8</a></td></tr>
<tr class="memdesc:a6ac67a3386892ea9daaa3974da649297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for vectors of uint8_t's, which can be used as smart strings.  <a href="vec_8h.html#a6ac67a3386892ea9daaa3974da649297">More...</a><br /></td></tr>
<tr class="separator:a6ac67a3386892ea9daaa3974da649297"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a904e79eacb27da124a159e60072cf285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904e79eacb27da124a159e60072cf285">&#9670;&nbsp;</a></span>cr8r_vec_pred</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* cr8r_vec_pred) (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *ent, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for predicates on vector elements. </p>
<p>These callbacks are provided with the vec_ft, the ent, and the data pointer passed to the caller </p>

<p class="definition">Definition at line <a class="el" href="vec_8h_source.html#l00069">69</a> of file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>

</div>
</div>
<a id="a6d44e1ee8740a1c6f03a15a9c64ce768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d44e1ee8740a1c6f03a15a9c64ce768">&#9670;&nbsp;</a></span>cr8r_vec_mapper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cr8r_vec_mapper) (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *src_ft, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *dest_ft, void *o, const void *e, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for functions mapping from one vector element type to another. </p>
<p>These callbacks are provided with the src_ft, dest_ft, dest ent pointer, src ent pointer, and data pointer passed to the caller </p>

<p class="definition">Definition at line <a class="el" href="vec_8h_source.html#l00074">74</a> of file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>

</div>
</div>
<a id="a8be8fd88d43867adc92c5de2a2e05cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be8fd88d43867adc92c5de2a2e05cb7">&#9670;&nbsp;</a></span>cr8r_vec_accumulator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* cr8r_vec_accumulator) (const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *acc, const void *e)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for accumulator functions on vectors (<a class="el" href="vec_8h.html#af519fece878d20ddc1c33daa4813aec9">cr8r_vec_foldl</a>) </p>
<p>These callbacks are provided with the vec_ft, pointer to the accumulator, and pointer to the ent </p>

<p class="definition">Definition at line <a class="el" href="vec_8h_source.html#l00079">79</a> of file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa8e5763aebc27e32c2913a674828e007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e5763aebc27e32c2913a674828e007">&#9670;&nbsp;</a></span>cr8r_vec_ft_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_ft_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, uint64_t cap)&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p, uint64_t cap)&#160;</td>
          <td class="paramname"><em>resize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p)&#160;</td>
          <td class="paramname"><em>del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src)&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *a, const void *b)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *a, void *b)&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to initialize a <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>. </p>
<p>Using standard structure initializer syntax with designated initializers may be simpler. However, this function automatically sets some functions to defaults if they are NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to user defined data to associate with the function table. generally NULL is sufficient. see <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> for a more in-depth explaination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single element in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>called to determine the capacity to grow to given the previous capacity (both in number of elements). Defaults to <a class="el" href="container_8h.html#afe863262f21f39d2d95940863e10d883">cr8r_default_new_size</a> which doubles the current size if it is nonzero or sets it to 8 otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resize</td><td>memory management function. Should "free" the buffer if cap is 0 (and do nothing if the current buffer is NULL). Should allocate a new buffer if the current buffer is NULL and cap is not 0. Otherwise, should resize the buffer to the requested size, possibly copying it to a new address. Defaults to <a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a> which is a good basic generic implementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>called on any element before deleting it. can be NULL if no action is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>copy an element. can be NULL if memcpy is sufficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparison function. must not be NULL to call search and sort functions. If NULL, no default will be provided, but <a class="el" href="container_8h.html#adb4b61e520c0cee3c3d074635d6cdef4">cr8r_default_cmp</a> can be used if memcmp is sufficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>swap two element. only required for a few functions (namely <a class="el" href="vec_8h.html#aa4b6dcca4bdbc7caf7df8a78525c3ef0">cr8r_vec_shuffle</a>). Defaults to <a class="el" href="container_8h.html#abaed3e57335670ca2dfbc304b75fede2">cr8r_default_swap</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if inputs are invalid, but currently all inputs are valid) </dd></dl>

</div>
</div>
<a id="a5d8cd0da55cbed50ba9a46811a807582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8cd0da55cbed50ba9a46811a807582">&#9670;&nbsp;</a></span>cr8r_vec_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a vector with an empty buffer of a given capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>how many entries to reserve space for initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="aaddb6c45cb315fe0582c59c53427bb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddb6c45cb315fe0582c59c53427bb1a">&#9670;&nbsp;</a></span>cr8r_vec_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all entries in a vector and free its buffer. </p>
<p>ft-&gt;del (can be NULL) is called on each element, then ft-&gt;resize is called to "resize" to 0. the fields of the vector are all zeroed out </p>

</div>
</div>
<a id="adf7f642d154e92357ef970feb3e5c138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7f642d154e92357ef970feb3e5c138">&#9670;&nbsp;</a></span>cr8r_vec_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a vector. </p>
<p>dest should NOT be initialized or its buffer will be leaked! Copies entries with ft-&gt;copy if applicable. The copy's capacity is only its length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to copy TO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to copy FROM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="ad967b976465b0055a5b89bfb8cd07bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad967b976465b0055a5b89bfb8cd07bbe">&#9670;&nbsp;</a></span>cr8r_vec_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a slice of a vector. </p>
<p>dest should NOT be initialized or its buffer will be leaked! Copies the range [ a : b ) from src to dest. Copies entries with ft-&gt;copy if applicable. The copy's capacity is only its length (b - a). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to copy TO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to copy FROM </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive start index and exclusive end index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure or invalid bounds) </dd></dl>

</div>
</div>
<a id="a2619b3844488731f3361d09ad76ef855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2619b3844488731f3361d09ad76ef855">&#9670;&nbsp;</a></span>cr8r_vec_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a vector's reserved buffer. </p>
<p>Can extend or shrink the buffer, but cannot make it smaller than its length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the target capacity, should not be less than the current length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation or invalid bounds) </dd></dl>

</div>
</div>
<a id="adc6c53aa17d83328eda34a5d1a94e3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6c53aa17d83328eda34a5d1a94e3ba">&#9670;&nbsp;</a></span>cr8r_vec_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a vector's reserved buffer to its length. </p>
<p>Exactly like <a class="el" href="vec_8h.html#a2619b3844488731f3361d09ad76ef855">cr8r_vec_resize</a> with self-&gt;len as the cap parameter </p><dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation, shouldn't happen unless ft-&gt;resize can fail to shrink) </dd></dl>

</div>
</div>
<a id="ac836b7eb6db947abf22dd5e69694814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac836b7eb6db947abf22dd5e69694814f">&#9670;&nbsp;</a></span>cr8r_vec_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from a vector. </p>
<p>Calls ft-&gt;del if applicable, and sets len to 0 </p>

</div>
</div>
<a id="aa4b6dcca4bdbc7caf7df8a78525c3ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b6dcca4bdbc7caf7df8a78525c3ef0">&#9670;&nbsp;</a></span>cr8r_vec_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the vector into a random permutation. </p>
<p>The algorithm produces permutations uniformly in theory, although in practice the number of permutations of a sufficiently large vector is enormously larger than the state space of any pseudorandom number generator. This won't cause any remotely meaningful patterns. </p>

</div>
</div>
<a id="aca7f424dd3f0a87649bf94995900b6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7f424dd3f0a87649bf94995900b6c8">&#9670;&nbsp;</a></span>cr8r_vec_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at a given index. </p>
<p>Similar to just doing self-&gt;buf + i*ft-&gt;base.size (recall that void pointer arithmetic acts like char pointer arithmetic), except that this function does bounds checking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element at index i, or NULL if i is out of bounds </dd></dl>

</div>
</div>
<a id="aabeda529e2562f99f42c1044e217cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeda529e2562f99f42c1044e217cc70">&#9670;&nbsp;</a></span>cr8r_vec_getx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_getx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at a given index, with support for negative indices. </p>
<p>Negative indicies work backwards, with -1 referring to the last element and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element at index i, or NULL if i is out of bounds </dd></dl>

</div>
</div>
<a id="aa2aefad9c344d8c7d9a25b236d813312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aefad9c344d8c7d9a25b236d813312">&#9670;&nbsp;</a></span>cr8r_vec_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_vec_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a vector. </p>
<p>Simply returns self-&gt;len </p><dl class="section return"><dt>Returns</dt><dd>the length of the vector </dd></dl>

</div>
</div>
<a id="a136fc6242ac747df5f8bfa71bfd7e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136fc6242ac747df5f8bfa71bfd7e70d">&#9670;&nbsp;</a></span>cr8r_vec_pushr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_pushr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the right hand end of a vector. </p>
<p>Vectors are arranged with increasing indicies at increasing memory addresses, so this is an O(1) operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the element to add, which is copied from this pointer into the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a599c09159cb69c595de1aff43ee10b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599c09159cb69c595de1aff43ee10b83">&#9670;&nbsp;</a></span>cr8r_vec_popr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_popr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the right hand end of a vector. </p>
<p>Vectors are arranged with increasing indicies at increasing memory addresses, so this is an O(1) operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>the removed element is copied here from the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (ie if the vector was empty) </dd></dl>

</div>
</div>
<a id="ac26bf98f8cc996edc8a3fe5560cd6353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26bf98f8cc996edc8a3fe5560cd6353">&#9670;&nbsp;</a></span>cr8r_vec_pushl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_pushl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the left hand end of a vector. </p>
<p>This is an O(n) operation because vectors are arranged with increasing indicies at increasing memory addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the element to add, which is copied from this pointer into the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ad1e46add615e3db6087de21050005522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e46add615e3db6087de21050005522">&#9670;&nbsp;</a></span>cr8r_vec_popl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_popl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the left hand end of a vector. </p>
<p>This is an O(n) operation because vectors are arranged with increasing indicies at increasing memory addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>the removed element is copied here from the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (ie if the vector was empty) </dd></dl>

</div>
</div>
<a id="a375928e0d906305237207ce0426b2486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375928e0d906305237207ce0426b2486">&#9670;&nbsp;</a></span>cr8r_vec_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a>&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a vector in-place. </p>
<p>ft-&gt;del is called on elements that fail the predicate, if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate to check elements with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>reentrant data to pass to the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation, shouldn't happen unless ft-&gt;resize can fail to shrink) </dd></dl>

</div>
</div>
<a id="a561c4ce5c4e2255ed4eeaa1bb3581ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561c4ce5c4e2255ed4eeaa1bb3581ff6">&#9670;&nbsp;</a></span>cr8r_vec_filtered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a>&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector as a subsequence matching a predicate. </p>
<p>dest should NOT be initialized or its buffer will be leaked! Iterate over the elements of a vector and copy them into a new vector if they match the predicate. ft-&gt;copy function is called if applicable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>vector to fill with filtered subsequence, should have a cap of 0 or valid buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>vector to copy filtered sequence from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate to check elements with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>reentrant data to pass to the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a7d099a5ea84cb4085c5ec194a59ec52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d099a5ea84cb4085c5ec194a59ec52f">&#9670;&nbsp;</a></span>cr8r_vec_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname"><em>src_ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname"><em>dest_ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a6d44e1ee8740a1c6f03a15a9c64ce768">cr8r_vec_mapper</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector by applying a transformation function to each element. </p>
<p>dest should NOT be initialized or its buffer will be leaked! This creates a new vector, whose element type and entire function table may be different. The transformation funtion also must perform any relevant work that ft-&gt;copy would have to, since the output element type is not necessarily the same as the input element type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>vector to fill with outputs of transformation function, should have a cap of 0 or valid buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>vector of elements to pass to the transformation function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_ft</td><td>function table for src vector <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_ft</td><td>function table for dest vector <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>transformation function. The first argument, o, is a pointer to the element in the destination vector to output to, and the second argument, e, is a pointer to the element in the source vector to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>reentrant data to pass to the transformation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a7e787957cf8bb14c7a6d60061af07173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e787957cf8bb14c7a6d60061af07173">&#9670;&nbsp;</a></span>cr8r_vec_forEachPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_vec_forEachPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *data)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on every permutation of a vector. </p>
<p>The vector is actually permuted in place using Heap's algorithm, and ends at the "last" permutation without being restored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>reentrant data to pass to the callback, can provide input, output, and persistant state without needing to hijack ft-&gt;base.data or similar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if an array of self-&gt;len uint64_t's cannot be allocated) </dd></dl>

</div>
</div>
<a id="a307ce32661ae90e4b3d5d751f9cea3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307ce32661ae90e4b3d5d751f9cea3ba">&#9670;&nbsp;</a></span>cr8r_vec_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector by concatenating copies of two given vectors. </p>
<p>dest should NOT be initialized or its buffer will be leaked! First, ensures the dest buffer has enough capacity for both src vectors, extending if necessary, then copy the vectors one after the other. ft-&gt;copy is called if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>vector in which to store result, should have a cap of 0 or valid buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_a,src_b</td><td>vectors to copy elements from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a5d51bc905d119424b59a57b6973041f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d51bc905d119424b59a57b6973041f5">&#9670;&nbsp;</a></span>cr8r_vec_augment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_augment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a copy of another vector to a given vector. </p>
<p>First, extends self-&gt;buf if needed, then copy the other vector right after the current end. ft-&gt;copy is called if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>vector to extend with a copy of the other vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>vector to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="aa09f92dfd14711cb40908e76b826389a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09f92dfd14711cb40908e76b826389a">&#9670;&nbsp;</a></span>cr8r_vec_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a>&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a predicate holds for all elements in a vector. </p>
<p>Returns false immediately if any element does not satisfy the predicate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on each element in the vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>reentrant data to pass to pred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the predicate function returns 1 on all elements, 0 (as soon as it doesn't) otherwise </dd></dl>

</div>
</div>
<a id="a051014ce44ee03d1f38e9bec0be0dfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051014ce44ee03d1f38e9bec0be0dfb3">&#9670;&nbsp;</a></span>cr8r_vec_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a904e79eacb27da124a159e60072cf285">cr8r_vec_pred</a>&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a predicate holds for any element in a vector. </p>
<p>Returns true immediately if any element satisfies the predicate. Note that this is completely equivalent to the negation of <a class="el" href="vec_8h.html#aa09f92dfd14711cb40908e76b826389a">cr8r_vec_all</a> with the negation of the predicate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on each element in the vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>reentrant data to pass to pred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 (as soon as) the predicate function returns 1 on any element, 0 if it returns 0 on all of them </dd></dl>

</div>
</div>
<a id="a6c46fe63b3e84780b58260594e79a30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c46fe63b3e84780b58260594e79a30a">&#9670;&nbsp;</a></span>cr8r_vec_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a vector contains a given element. </p>
<p>This is O(n) because it does not assume a sorted vector and simply does a linear search. See <a class="el" href="vec_8h.html#aeee6e47feb7b49bf85b42d29acc41240">cr8r_vec_containss</a> for a binary search version that does require a sorted vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the vector contains the element, 0 otherwise </dd></dl>

</div>
</div>
<a id="a3b32323f2ef92ca85694161725826e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b32323f2ef92ca85694161725826e97">&#9670;&nbsp;</a></span>cr8r_vec_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cr8r_vec_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first index of an element in a vector. </p>
<p>This is O(n) because it does not assume a sorted vector and simply does a linear search. See <a class="el" href="vec_8h.html#ae9591ba11330afa82d760d0ad111d410">cr8r_vec_indexs</a> for a binary search version that does require a sorted vector. Returns -1 on failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the element if it is in the vector, or -1 otherwise </dd></dl>

</div>
</div>
<a id="a132b16ba4b1de994c74a4ef8762a0224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132b16ba4b1de994c74a4ef8762a0224">&#9670;&nbsp;</a></span>cr8r_vec_exm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_exm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the extremal (minimum or maximum) element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ord</td><td>1 for minimum or -1 for maximum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the extremal element, or NULL if the vector is empty </dd></dl>

</div>
</div>
<a id="ac300459e0111780316db62fc1aa54d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac300459e0111780316db62fc1aa54d4c">&#9670;&nbsp;</a></span>cr8r_vec_foldr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_foldr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a8be8fd88d43867adc92c5de2a2e05cb7">cr8r_vec_accumulator</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a right fold on a vector. </p>
<p>Given an initial accumulator value of some type T in a void pointer, a vector, and a function that takes a void pointer to a T value and an element of the vector and returns a void pointer to a T value, this function repeatedly applies that function to the current accumulator value and vector element to get the new accumulator value. This is repeated for every element in the vector, going from left to right (low indices to high), and the final accumulator value is returned. The accumulation function must handle freeing old accumulator values once it is finished with them if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>starting value for the accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>accumulation function: should take current accumulator value (as void pointer) and current vector element and return new accumulator value. It should either modify the accumulator value in place, returning it as well, or allocate a new pointer for the new accumulator value and free the old one once the new one has been computed. In cases where the accumulator value is an integer or something else that fits within a pointer, the pointer can be used as a casted integer or whatnot instead of as a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final accumulator value </dd></dl>

</div>
</div>
<a id="af519fece878d20ddc1c33daa4813aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af519fece878d20ddc1c33daa4813aec9">&#9670;&nbsp;</a></span>cr8r_vec_foldl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_foldl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vec_8h.html#a8be8fd88d43867adc92c5de2a2e05cb7">cr8r_vec_accumulator</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a left fold on a vector. </p>
<p>Exactly the same as <a class="el" href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">cr8r_vec_foldr</a> except vector entries are processed from right to left (high indices to low) instead of left to right (low to high). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>starting value for the accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>accumulation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final accumulator value </dd></dl>

</div>
</div>
<a id="a9bcbace693b2aa77a48b55291d74ad4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcbace693b2aa77a48b55291d74ad4f">&#9670;&nbsp;</a></span>cr8r_vec_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a vector in-place according to ft-&gt;cmp. </p>
<p>Currently uses heapsort, so average and worst case time complexities are both O(n*log(n)). </p>

</div>
</div>
<a id="ae21dbfd3a9e07c60aeaade8c795e252c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21dbfd3a9e07c60aeaade8c795e252c">&#9670;&nbsp;</a></span>cr8r_vec_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sorted copy of a vector. </p>
<p>Simply calls <a class="el" href="vec_8h.html#adf7f642d154e92357ef970feb3e5c138">cr8r_vec_copy</a> followed by <a class="el" href="vec_8h.html#a9bcbace693b2aa77a48b55291d74ad4f">cr8r_vec_sort</a> on the copy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to copy to and sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="ae6f8d8acbaa9e05a05deb6173fb203ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f8d8acbaa9e05a05deb6173fb203ae">&#9670;&nbsp;</a></span>cr8r_vec_reversed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_reversed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a reversed copy of a vector. </p>
<p>copies elements in reverse order, using ft-&gt;copy if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to store the reversed copy in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to create a reversed copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="aeee6e47feb7b49bf85b42d29acc41240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee6e47feb7b49bf85b42d29acc41240">&#9670;&nbsp;</a></span>cr8r_vec_containss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_containss </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a sorted vector contains an element. </p>
<p>The vector should be in ascending order according to ft-&gt;cmp. Uses binary search, so the average and worst case time complexities are O(log(n)). If the elements are sorted and belong to some known distribution, some form of interpolation seach could work even faster, but this is best implemented as a custom function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the vector contains the element, 0 otherwise </dd></dl>

</div>
</div>
<a id="ae9591ba11330afa82d760d0ad111d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9591ba11330afa82d760d0ad111d410">&#9670;&nbsp;</a></span>cr8r_vec_indexs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cr8r_vec_indexs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of an element in a sorted vector. </p>
<p>The vector should be in ascending order according to ft-&gt;cmp. If there are multiple elements which compare equal to the query, the index of any one of them may be returned. Uses binary search, so the average and worst case time complexities are O(log(n)). If the elements are sorted and belong to some known distribution, some form of interpolation seach could work even faster, but this is best implemented as a custom function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the element in the vector, or -1 if not present </dd></dl>

</div>
</div>
<a id="ab4b70ed397697cecf35ff74c2f8a0b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b70ed397697cecf35ff74c2f8a0b7d">&#9670;&nbsp;</a></span>cr8r_vec_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_vec_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographically compare two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>vectors to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if a is lexicographically before b, +1 visa versa, or 0 if they are equal </dd></dl>

</div>
</div>
<a id="a31eb8c7f28d1a6f930ef725634050d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eb8c7f28d1a6f930ef725634050d57">&#9670;&nbsp;</a></span>cr8r_vec_pivot_m3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_pivot_m3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pick a pivot for <a class="el" href="vec_8h.html#ac1aab02695f085893fbfbe7f5ad7b476">cr8r_vec_partition</a> using the median of 3 approach. </p>
<p>This is an O(1) pivot selection algorithm that can cause quicksort/quickselect to perform badly (O(n**2)) in pathological cases, but most of the time works very well (O(n*log(n)) and faster than <a class="el" href="vec_8h.html#a4cb20ca700c0e4d90dc5c649b4844f5c">cr8r_vec_pivot_mm</a> in practice most of the time). Picks the median of the first, middle (rounded down), and last elements. In the event of ties, which valid element is chosen is not specified, but is consistent for the same elements. The vector is not modified </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive, exclusive indices of the subrange to pick a pivot for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the selected pivot, or NULL if a and b are not valid subrange indices for the given vector. </dd></dl>

</div>
</div>
<a id="a4cb20ca700c0e4d90dc5c649b4844f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb20ca700c0e4d90dc5c649b4844f5c">&#9670;&nbsp;</a></span>cr8r_vec_pivot_mm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_pivot_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pick a pivot for <a class="el" href="vec_8h.html#ac1aab02695f085893fbfbe7f5ad7b476">cr8r_vec_partition</a> using the median of medians approach. </p>
<p>This is an O(n) pivot selection algorithm that ensures quicksort/quickselect will always run in O(n*log(n)) time. However, because the entire subrange is processed, this will often end up slower than <a class="el" href="vec_8h.html#a31eb8c7f28d1a6f930ef725634050d57">cr8r_vec_pivot_m3</a>. The reason median of medians ensures quicksort/quickselect will finish in O(n*log(n)) time is because it will select a pivot whose index is within a certain ratio of the median (eg if the subrange has k elements then the pivot selected will be one of the central a*k elements for some small fixed coefficient). The median of medians algorithm used does not allocate extra space, but the order of the given subrange is not preserved. Picks the median of the first, middle (rounded down), and last elements. In the event of ties, which valid element is chosen is not specified, but is consistent for the same elements. The vector to pick a pivot for (a subrange of), will be reordered in place, but only within the given subrange </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive, exclusive indices of the subrange to pick a pivot for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the selected pivot, or NULL if a and b are not valid subrange indices for the given vector. because the target subrange is reordered so the algorithm can run in place, the pivot will always end up at index a, but this should not be relied on. </dd></dl>

</div>
</div>
<a id="ac1aab02695f085893fbfbe7f5ad7b476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aab02695f085893fbfbe7f5ad7b476">&#9670;&nbsp;</a></span>cr8r_vec_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a subrange of a vector into elements &lt; a pivot and elements &gt;= a pivot. </p>
<p>The given subrange is rearranged so that all elements before the pivot are &lt; the pivot and all elements &gt;= the pivot are after the pivot, and a pointer to the pivot is returned the vector has its relevant subrange reordered in place </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive, exclusive bounds of subrange (ie, consider elements [a, b)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">piv</td><td>a pointer to the pivot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the pivot, which was placed after all elements &lt; itself but before all other elements &gt;= itself </dd></dl>

</div>
</div>
<a id="ad91efeb6db8a8931cb0ae2598ebf1125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91efeb6db8a8931cb0ae2598ebf1125">&#9670;&nbsp;</a></span>cr8r_vec_partition_with_median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_partition_with_median </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>piv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a subrange of a vector into elements &lt;, ==, and &gt; a pivot. </p>
<p>The given subrange is rearranged so that all elements &lt; the pivot occur first, followed by all elements == the pivot (including the pivot), then finally all elements </p><blockquote class="doxtable">
<p>the pivot. A pointer to the ending position of the pivot is returned. </p>
</blockquote>
<p>Notice in particular that if piv is the ith element in sorted order, calling this function will actually place that element (or an == one) at the ith index, with the subrange arranged into a &lt;, ==, and &gt; block as just described the vector has its relevant subrange reordered in place </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive, exclusive bounds of subrange (ie, consider elements [a, b)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">piv</td><td>a pointer to the pivot (usually obtained from <a class="el" href="vec_8h.html#af5e0c1ec199b4f22f35722da8e379707">cr8r_vec_ith</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the pivot, which was moved to somewhere in the == block </dd></dl>

</div>
</div>
<a id="af5e0c1ec199b4f22f35722da8e379707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e0c1ec199b4f22f35722da8e379707">&#9670;&nbsp;</a></span>cr8r_vec_ith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_ith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the ith element of a subrange of a vector without completely sorting it. </p>
<p>The given subrange is partitioned in place, but the quickselect algorithm is used rather than sorting so the expected running time is linear. Using median of medians would guarantee linear time, but median of 3 is good enough most of the time. The vector to find ith element of may be reoredered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive, exclusive bounds of subrange </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index to find. For example, 0 finds the smallest element, 1 the second smallest, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b302c782e6b375225feb30bbc371cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b302c782e6b375225feb30bbc371cfd">&#9670;&nbsp;</a></span>cr8r_default_acc_sum_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_acc_sum_u64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">cr8r_vec_foldr</a> to sum up elements in vector. </p>
<p>The acc argument is treated as a uint64_t, NOT a pointer to uint64_t. Thus the call can be (uint64_t)cr8r_vec_foldr(self, ft, (void*)0, cr8r_default_acc_sum_u64). </p>

</div>
</div>
<a id="af164e28b1cf34667ea868a3a05348695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af164e28b1cf34667ea868a3a05348695">&#9670;&nbsp;</a></span>cr8r_default_acc_sumpowmod_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_acc_sumpowmod_u64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="vec_8h.html#ac300459e0111780316db62fc1aa54d4c">cr8r_vec_foldr</a> to sum up powers of elements in a vector mod a number. </p>
<p>The acc argument MUST be a pointer to three consecutive uint64_t's: the accumulator, the exponent, and the modulus, respectively. The same pointer is returned: the accumulator is modified in place. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab7772f368e5b8af85b466188fbf941e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7772f368e5b8af85b466188fbf941e3">&#9670;&nbsp;</a></span>cr8r_vecft_u64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> cr8r_vecft_u64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function table for vectors of uint64_t's. </p>
<p>Trivial copy/swap and <a class="el" href="container_8h.html#a90ff4cc5be3eba687bcfac84f6b05c5e">cr8r_default_cmp_u64</a> are used, plus the default allocation scheme <a class="el" href="container_8h.html#afe863262f21f39d2d95940863e10d883">cr8r_default_new_size</a> and <a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a>. </p>

</div>
</div>
<a id="af026cd1e578946255a90070d80d4b507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af026cd1e578946255a90070d80d4b507">&#9670;&nbsp;</a></span>cr8r_vecft_cstr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> cr8r_vecft_cstr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function table for vectors of strings. </p>
<p>Strings are null-terminated and "owned" by the vector. Trivial swap, strdup copy, <a class="el" href="container_8h.html#ae0e18a2a1ac7dea3ced1b4dc320ef11b">cr8r_default_cmp_cstr</a>, and <a class="el" href="container_8h.html#a3dc2070a9246a4e03ef6571f40e5c0ce">cr8r_default_free</a>. The default allocation scheme of <a class="el" href="container_8h.html#afe863262f21f39d2d95940863e10d883">cr8r_default_new_size</a> and <a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a> is used for the vector itself. </p>

</div>
</div>
<a id="a6ac67a3386892ea9daaa3974da649297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac67a3386892ea9daaa3974da649297">&#9670;&nbsp;</a></span>cr8r_vecft_u8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> cr8r_vecft_u8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function table for vectors of uint8_t's, which can be used as smart strings. </p>
<p>Trivial copy/swap and <a class="el" href="container_8h.html#a2e71c6f60f2a255de6850c127fabfa56">cr8r_default_cmp_u8</a> are used, plus the default allocation scheme <a class="el" href="container_8h.html#afe863262f21f39d2d95940863e10d883">cr8r_default_new_size</a> and <a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li><li class="navelem"><a class="el" href="vec_8h.html">vec.h</a></li>
    <li class="footer">Generated on Tue Mar 1 2022 23:03:58 for Crater Container Library by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
