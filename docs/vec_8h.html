<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/vec.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crater Container Library
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vec.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;<a class="el" href="container_8h_source.html">crater/container.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="prand_8h_source.html">crater/prand.h</a>&gt;</code><br />
</div>
<p><a href="vec_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__vec.html">cr8r_vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector Take care if manipulating these fields directly, this should only be done if the functions in this file are not sufficient.  <a href="structcr8r__vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad6ad2c8ac3e2aa3305c661e8b6ce1d5a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad6ad2c8ac3e2aa3305c661e8b6ce1d5a">cr8r_vec_ft</a></td></tr>
<tr class="memdesc:ad6ad2c8ac3e2aa3305c661e8b6ce1d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for vector.  <a href="vec_8h.html#ad6ad2c8ac3e2aa3305c661e8b6ce1d5a">More...</a><br /></td></tr>
<tr class="separator:ad6ad2c8ac3e2aa3305c661e8b6ce1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8e5763aebc27e32c2913a674828e007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa8e5763aebc27e32c2913a674828e007">cr8r_vec_ft_init</a> (<a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *data, uint64_t size, uint64_t(*new_size)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, uint64_t cap), void *(*resize)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p, uint64_t cap), void(*del)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p), void(*copy)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src), int(*cmp)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *a, const void *b), void(*swap)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *a, void *b))</td></tr>
<tr class="memdesc:aa8e5763aebc27e32c2913a674828e007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to initialize a <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>.  <a href="vec_8h.html#aa8e5763aebc27e32c2913a674828e007">More...</a><br /></td></tr>
<tr class="separator:aa8e5763aebc27e32c2913a674828e007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8cd0da55cbed50ba9a46811a807582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a5d8cd0da55cbed50ba9a46811a807582">cr8r_vec_init</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t cap)</td></tr>
<tr class="memdesc:a5d8cd0da55cbed50ba9a46811a807582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a vector with an empty buffer of a given capacity.  <a href="vec_8h.html#a5d8cd0da55cbed50ba9a46811a807582">More...</a><br /></td></tr>
<tr class="separator:a5d8cd0da55cbed50ba9a46811a807582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb6c45cb315fe0582c59c53427bb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aaddb6c45cb315fe0582c59c53427bb1a">cr8r_vec_delete</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:aaddb6c45cb315fe0582c59c53427bb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all entries in a vector and free its buffer.  <a href="vec_8h.html#aaddb6c45cb315fe0582c59c53427bb1a">More...</a><br /></td></tr>
<tr class="separator:aaddb6c45cb315fe0582c59c53427bb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7f642d154e92357ef970feb3e5c138"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#adf7f642d154e92357ef970feb3e5c138">cr8r_vec_copy</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:adf7f642d154e92357ef970feb3e5c138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a vector.  <a href="vec_8h.html#adf7f642d154e92357ef970feb3e5c138">More...</a><br /></td></tr>
<tr class="separator:adf7f642d154e92357ef970feb3e5c138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad967b976465b0055a5b89bfb8cd07bbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad967b976465b0055a5b89bfb8cd07bbe">cr8r_vec_sub</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:ad967b976465b0055a5b89bfb8cd07bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a slice of a vector.  <a href="vec_8h.html#ad967b976465b0055a5b89bfb8cd07bbe">More...</a><br /></td></tr>
<tr class="separator:ad967b976465b0055a5b89bfb8cd07bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2619b3844488731f3361d09ad76ef855"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a2619b3844488731f3361d09ad76ef855">cr8r_vec_resize</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t cap)</td></tr>
<tr class="memdesc:a2619b3844488731f3361d09ad76ef855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a vector's reserved buffer.  <a href="vec_8h.html#a2619b3844488731f3361d09ad76ef855">More...</a><br /></td></tr>
<tr class="separator:a2619b3844488731f3361d09ad76ef855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6c53aa17d83328eda34a5d1a94e3ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#adc6c53aa17d83328eda34a5d1a94e3ba">cr8r_vec_trim</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:adc6c53aa17d83328eda34a5d1a94e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a vector's reserved buffer to its length.  <a href="vec_8h.html#adc6c53aa17d83328eda34a5d1a94e3ba">More...</a><br /></td></tr>
<tr class="separator:adc6c53aa17d83328eda34a5d1a94e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac836b7eb6db947abf22dd5e69694814f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ac836b7eb6db947abf22dd5e69694814f">cr8r_vec_clear</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ac836b7eb6db947abf22dd5e69694814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from a vector.  <a href="vec_8h.html#ac836b7eb6db947abf22dd5e69694814f">More...</a><br /></td></tr>
<tr class="separator:ac836b7eb6db947abf22dd5e69694814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b6dcca4bdbc7caf7df8a78525c3ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa4b6dcca4bdbc7caf7df8a78525c3ef0">cr8r_vec_shuffle</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, <a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:aa4b6dcca4bdbc7caf7df8a78525c3ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the vector into a random permutation.  <a href="vec_8h.html#aa4b6dcca4bdbc7caf7df8a78525c3ef0">More...</a><br /></td></tr>
<tr class="separator:aa4b6dcca4bdbc7caf7df8a78525c3ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7f424dd3f0a87649bf94995900b6c8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aca7f424dd3f0a87649bf94995900b6c8">cr8r_vec_get</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, uint64_t i)</td></tr>
<tr class="memdesc:aca7f424dd3f0a87649bf94995900b6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at a given index.  <a href="vec_8h.html#aca7f424dd3f0a87649bf94995900b6c8">More...</a><br /></td></tr>
<tr class="separator:aca7f424dd3f0a87649bf94995900b6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeda529e2562f99f42c1044e217cc70"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aabeda529e2562f99f42c1044e217cc70">cr8r_vec_getx</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, int64_t i)</td></tr>
<tr class="memdesc:aabeda529e2562f99f42c1044e217cc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at a given index, with support for negative indices.  <a href="vec_8h.html#aabeda529e2562f99f42c1044e217cc70">More...</a><br /></td></tr>
<tr class="separator:aabeda529e2562f99f42c1044e217cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aefad9c344d8c7d9a25b236d813312"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aa2aefad9c344d8c7d9a25b236d813312">cr8r_vec_len</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *)</td></tr>
<tr class="memdesc:aa2aefad9c344d8c7d9a25b236d813312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a vector.  <a href="vec_8h.html#aa2aefad9c344d8c7d9a25b236d813312">More...</a><br /></td></tr>
<tr class="separator:aa2aefad9c344d8c7d9a25b236d813312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136fc6242ac747df5f8bfa71bfd7e70d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a136fc6242ac747df5f8bfa71bfd7e70d">cr8r_vec_pushr</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a136fc6242ac747df5f8bfa71bfd7e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the right hand end of a vector.  <a href="vec_8h.html#a136fc6242ac747df5f8bfa71bfd7e70d">More...</a><br /></td></tr>
<tr class="separator:a136fc6242ac747df5f8bfa71bfd7e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599c09159cb69c595de1aff43ee10b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a599c09159cb69c595de1aff43ee10b83">cr8r_vec_popr</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *o)</td></tr>
<tr class="memdesc:a599c09159cb69c595de1aff43ee10b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the right hand end of a vector.  <a href="vec_8h.html#a599c09159cb69c595de1aff43ee10b83">More...</a><br /></td></tr>
<tr class="separator:a599c09159cb69c595de1aff43ee10b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26bf98f8cc996edc8a3fe5560cd6353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ac26bf98f8cc996edc8a3fe5560cd6353">cr8r_vec_pushl</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:ac26bf98f8cc996edc8a3fe5560cd6353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the left hand end of a vector.  <a href="vec_8h.html#ac26bf98f8cc996edc8a3fe5560cd6353">More...</a><br /></td></tr>
<tr class="separator:ac26bf98f8cc996edc8a3fe5560cd6353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e46add615e3db6087de21050005522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad1e46add615e3db6087de21050005522">cr8r_vec_popl</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *o)</td></tr>
<tr class="memdesc:ad1e46add615e3db6087de21050005522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the left hand end of a vector.  <a href="vec_8h.html#ad1e46add615e3db6087de21050005522">More...</a><br /></td></tr>
<tr class="separator:ad1e46add615e3db6087de21050005522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf4d21bfe0ecf4236689abbcdd9692"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a9dbf4d21bfe0ecf4236689abbcdd9692">cr8r_vec_filter</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:a9dbf4d21bfe0ecf4236689abbcdd9692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a vector in-place.  <a href="vec_8h.html#a9dbf4d21bfe0ecf4236689abbcdd9692">More...</a><br /></td></tr>
<tr class="separator:a9dbf4d21bfe0ecf4236689abbcdd9692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308fb59b1a449476504fa42ef604503b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a308fb59b1a449476504fa42ef604503b">cr8r_vec_filtered</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:a308fb59b1a449476504fa42ef604503b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector as a subsequence matching a predicate.  <a href="vec_8h.html#a308fb59b1a449476504fa42ef604503b">More...</a><br /></td></tr>
<tr class="separator:a308fb59b1a449476504fa42ef604503b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e5fe3e3e68886fe5fc7c81cdd60951"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a62e5fe3e3e68886fe5fc7c81cdd60951">cr8r_vec_map</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *src_ft, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *dest_ft, void(*f)(void *o, const void *e))</td></tr>
<tr class="memdesc:a62e5fe3e3e68886fe5fc7c81cdd60951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector by applying a transformation function to each element.  <a href="vec_8h.html#a62e5fe3e3e68886fe5fc7c81cdd60951">More...</a><br /></td></tr>
<tr class="separator:a62e5fe3e3e68886fe5fc7c81cdd60951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c93576eec9e423ae336cec9e1fb42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad46c93576eec9e423ae336cec9e1fb42">cr8r_vec_forEachPermutation</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void(*f)(const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *))</td></tr>
<tr class="memdesc:ad46c93576eec9e423ae336cec9e1fb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on every permutation of a vector.  <a href="vec_8h.html#ad46c93576eec9e423ae336cec9e1fb42">More...</a><br /></td></tr>
<tr class="separator:ad46c93576eec9e423ae336cec9e1fb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307ce32661ae90e4b3d5d751f9cea3ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a307ce32661ae90e4b3d5d751f9cea3ba">cr8r_vec_combine</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src_a, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src_b, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a307ce32661ae90e4b3d5d751f9cea3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector by concatenating copies of two given vectors.  <a href="vec_8h.html#a307ce32661ae90e4b3d5d751f9cea3ba">More...</a><br /></td></tr>
<tr class="separator:a307ce32661ae90e4b3d5d751f9cea3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d51bc905d119424b59a57b6973041f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a5d51bc905d119424b59a57b6973041f5">cr8r_vec_augment</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *self, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *other, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a5d51bc905d119424b59a57b6973041f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a copy of another vector to a given vector.  <a href="vec_8h.html#a5d51bc905d119424b59a57b6973041f5">More...</a><br /></td></tr>
<tr class="separator:a5d51bc905d119424b59a57b6973041f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b8a19195b2639c4f526423272c07ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ad8b8a19195b2639c4f526423272c07ad">cr8r_vec_all</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:ad8b8a19195b2639c4f526423272c07ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a predicate holds for all elements in a vector.  <a href="vec_8h.html#ad8b8a19195b2639c4f526423272c07ad">More...</a><br /></td></tr>
<tr class="separator:ad8b8a19195b2639c4f526423272c07ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991f7bd28dd220d5d889354f8ba7f64b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a991f7bd28dd220d5d889354f8ba7f64b">cr8r_vec_any</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, bool(*pred)(const void *))</td></tr>
<tr class="memdesc:a991f7bd28dd220d5d889354f8ba7f64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a predicate holds for any element in a vector.  <a href="vec_8h.html#a991f7bd28dd220d5d889354f8ba7f64b">More...</a><br /></td></tr>
<tr class="separator:a991f7bd28dd220d5d889354f8ba7f64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c46fe63b3e84780b58260594e79a30a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a6c46fe63b3e84780b58260594e79a30a">cr8r_vec_contains</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a6c46fe63b3e84780b58260594e79a30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a vector contains a given element.  <a href="vec_8h.html#a6c46fe63b3e84780b58260594e79a30a">More...</a><br /></td></tr>
<tr class="separator:a6c46fe63b3e84780b58260594e79a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b32323f2ef92ca85694161725826e97"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a3b32323f2ef92ca85694161725826e97">cr8r_vec_index</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:a3b32323f2ef92ca85694161725826e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of an element in a vector.  <a href="vec_8h.html#a3b32323f2ef92ca85694161725826e97">More...</a><br /></td></tr>
<tr class="separator:a3b32323f2ef92ca85694161725826e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39842910c332246a6b58d89b7ce8aa52"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">cr8r_vec_foldr</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *init, void *(*f)(void *acc, const void *e))</td></tr>
<tr class="memdesc:a39842910c332246a6b58d89b7ce8aa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a right fold on a vector.  <a href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">More...</a><br /></td></tr>
<tr class="separator:a39842910c332246a6b58d89b7ce8aa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467b6a8b19b8ab8c55b2bb1abf855a0f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a467b6a8b19b8ab8c55b2bb1abf855a0f">cr8r_vec_foldl</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, void *init, void *(*f)(void *acc, const void *e))</td></tr>
<tr class="memdesc:a467b6a8b19b8ab8c55b2bb1abf855a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold on a vector.  <a href="vec_8h.html#a467b6a8b19b8ab8c55b2bb1abf855a0f">More...</a><br /></td></tr>
<tr class="separator:a467b6a8b19b8ab8c55b2bb1abf855a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcbace693b2aa77a48b55291d74ad4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a9bcbace693b2aa77a48b55291d74ad4f">cr8r_vec_sort</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a9bcbace693b2aa77a48b55291d74ad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a vector in-place according to ft-&gt;cmp.  <a href="vec_8h.html#a9bcbace693b2aa77a48b55291d74ad4f">More...</a><br /></td></tr>
<tr class="separator:a9bcbace693b2aa77a48b55291d74ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21dbfd3a9e07c60aeaade8c795e252c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae21dbfd3a9e07c60aeaade8c795e252c">cr8r_vec_sorted</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ae21dbfd3a9e07c60aeaade8c795e252c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sorted copy of a vector.  <a href="vec_8h.html#ae21dbfd3a9e07c60aeaade8c795e252c">More...</a><br /></td></tr>
<tr class="separator:ae21dbfd3a9e07c60aeaade8c795e252c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086baaf5b286b06c10ba63a9bc41244e"><td class="memItemLeft" align="right" valign="top"><a id="a086baaf5b286b06c10ba63a9bc41244e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a086baaf5b286b06c10ba63a9bc41244e">cr8r_vec_reverse</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:a086baaf5b286b06c10ba63a9bc41244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a vector in place. <br /></td></tr>
<tr class="separator:a086baaf5b286b06c10ba63a9bc41244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f8d8acbaa9e05a05deb6173fb203ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae6f8d8acbaa9e05a05deb6173fb203ae">cr8r_vec_reversed</a> (<a class="el" href="structcr8r__vec.html">cr8r_vec</a> *dest, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *src, <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ae6f8d8acbaa9e05a05deb6173fb203ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reversed copy of a vector.  <a href="vec_8h.html#ae6f8d8acbaa9e05a05deb6173fb203ae">More...</a><br /></td></tr>
<tr class="separator:ae6f8d8acbaa9e05a05deb6173fb203ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee6e47feb7b49bf85b42d29acc41240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#aeee6e47feb7b49bf85b42d29acc41240">cr8r_vec_containss</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:aeee6e47feb7b49bf85b42d29acc41240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a sorted vector contains an element.  <a href="vec_8h.html#aeee6e47feb7b49bf85b42d29acc41240">More...</a><br /></td></tr>
<tr class="separator:aeee6e47feb7b49bf85b42d29acc41240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9591ba11330afa82d760d0ad111d410"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ae9591ba11330afa82d760d0ad111d410">cr8r_vec_indexs</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *, const void *e)</td></tr>
<tr class="memdesc:ae9591ba11330afa82d760d0ad111d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of an element in a sorted vector.  <a href="vec_8h.html#ae9591ba11330afa82d760d0ad111d410">More...</a><br /></td></tr>
<tr class="separator:ae9591ba11330afa82d760d0ad111d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b70ed397697cecf35ff74c2f8a0b7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#ab4b70ed397697cecf35ff74c2f8a0b7d">cr8r_vec_cmp</a> (const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *a, const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *b, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)</td></tr>
<tr class="memdesc:ab4b70ed397697cecf35ff74c2f8a0b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compare two vectors.  <a href="vec_8h.html#ab4b70ed397697cecf35ff74c2f8a0b7d">More...</a><br /></td></tr>
<tr class="separator:ab4b70ed397697cecf35ff74c2f8a0b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1184bc298656ebf85ea805949148bead"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a1184bc298656ebf85ea805949148bead">cr8r_default_acc_sum_u64</a> (void *, const void *)</td></tr>
<tr class="memdesc:a1184bc298656ebf85ea805949148bead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">cr8r_vec_foldr</a> to sum up elements in vector.  <a href="vec_8h.html#a1184bc298656ebf85ea805949148bead">More...</a><br /></td></tr>
<tr class="separator:a1184bc298656ebf85ea805949148bead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188b2103e12f33772f020668bbc474ea"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vec_8h.html#a188b2103e12f33772f020668bbc474ea">cr8r_default_acc_sumpowmod_u64</a> (void *, const void *)</td></tr>
<tr class="memdesc:a188b2103e12f33772f020668bbc474ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">cr8r_vec_foldr</a> to sum up powers of elements in a vector mod a number.  <a href="vec_8h.html#a188b2103e12f33772f020668bbc474ea">More...</a><br /></td></tr>
<tr class="separator:a188b2103e12f33772f020668bbc474ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab7772f368e5b8af85b466188fbf941e3"><td class="memItemLeft" align="right" valign="top"><a id="ab7772f368e5b8af85b466188fbf941e3"></a>
<a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cr8r_vecft_u64</b></td></tr>
<tr class="separator:ab7772f368e5b8af85b466188fbf941e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Simple, featureful generic vector </p>

<p class="definition">Definition in file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad6ad2c8ac3e2aa3305c661e8b6ce1d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ad2c8ac3e2aa3305c661e8b6ce1d5a">&#9670;&nbsp;</a></span>cr8r_vec_ft</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function table for vector. </p>
<p>Imagine this struct as the class of the vector. This struct specifies the size of the elements in a vector in bytes, as well as how to perform necessary operations (compare, copy, etc). Remember that function tables must be initialized manually. In particular, the cr8r_vec_default_* functions can be used as decent defaults, but must be explicitly set. </p>

<p class="definition">Definition at line <a class="el" href="vec_8h_source.html#l00038">38</a> of file <a class="el" href="vec_8h_source.html">vec.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa8e5763aebc27e32c2913a674828e007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e5763aebc27e32c2913a674828e007">&#9670;&nbsp;</a></span>cr8r_vec_ft_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_ft_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, uint64_t cap)&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p, uint64_t cap)&#160;</td>
          <td class="paramname"><em>resize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *p)&#160;</td>
          <td class="paramname"><em>del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *dest, const void *src)&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, const void *a, const void *b)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> *, void *a, void *b)&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to initialize a <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a>. </p>
<p>Using standard structure initializer syntax with designated initializers may be simpler. However, this function provides basic checking (it checks the required functions aren't NULL). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to user defined data to associate with the function table. generally NULL is sufficient. see <a class="el" href="structcr8r__base__ft.html">cr8r_base_ft</a> for a more in-depth explaination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single element in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>called to determine the capacity to grow to given the previous capacity (both in number of elements) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resize</td><td>memory management function. Should "free" the buffer if cap is 0 (and do nothing if the current buffer is NULL). Should allocate a new buffer if the current buffer is NULL and cap is not 0. Otherwise, should resize the buffer to the requested size, possibly copying it to a new address. See <a class="el" href="container_8h.html#a298ab3d3cf336dc71468fd55493c6a1d">cr8r_default_resize</a> for a basic generic implementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>called on any element before deleting it. can be NULL if no action is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>copy an element. can be NULL if memcpy is sufficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparison function. must not be NULL to call search and sort functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>swap two element. only required for a few functions (namely <a class="el" href="vec_8h.html#aa4b6dcca4bdbc7caf7df8a78525c3ef0">cr8r_vec_shuffle</a>). <a class="el" href="container_8h.html#abaed3e57335670ca2dfbc304b75fede2">cr8r_default_swap</a> is a good generic choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if resize is NULL) </dd></dl>

</div>
</div>
<a id="a5d8cd0da55cbed50ba9a46811a807582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8cd0da55cbed50ba9a46811a807582">&#9670;&nbsp;</a></span>cr8r_vec_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a vector with an empty buffer of a given capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>how many entries to reserve space for initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="aaddb6c45cb315fe0582c59c53427bb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddb6c45cb315fe0582c59c53427bb1a">&#9670;&nbsp;</a></span>cr8r_vec_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all entries in a vector and free its buffer. </p>
<p>ft-&gt;del (can be NULL) is called on each element, then ft-&gt;resize is called to "resize" to 0. the fields of the vector are all zeroed out </p>

</div>
</div>
<a id="adf7f642d154e92357ef970feb3e5c138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7f642d154e92357ef970feb3e5c138">&#9670;&nbsp;</a></span>cr8r_vec_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a vector. </p>
<p>Copies entries with ft-&gt;copy if applicable. The copy's capacity is only its length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to copy TO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to copy FROM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="ad967b976465b0055a5b89bfb8cd07bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad967b976465b0055a5b89bfb8cd07bbe">&#9670;&nbsp;</a></span>cr8r_vec_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of a slice of a vector. </p>
<p>Copies the range [ a : b ) from src to dest. Copies entries with ft-&gt;copy if applicable. The copy's capacity is only its length (b - a). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to copy TO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to copy FROM </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>inclusive start index and exclusive end index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure or invalid bounds) </dd></dl>

</div>
</div>
<a id="a2619b3844488731f3361d09ad76ef855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2619b3844488731f3361d09ad76ef855">&#9670;&nbsp;</a></span>cr8r_vec_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a vector's reserved buffer. </p>
<p>Can extend or shrink the buffer, but cannot make it smaller than its length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>the target capacity, should not be less than the current length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation or invalid bounds) </dd></dl>

</div>
</div>
<a id="adc6c53aa17d83328eda34a5d1a94e3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6c53aa17d83328eda34a5d1a94e3ba">&#9670;&nbsp;</a></span>cr8r_vec_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a vector's reserved buffer to its length. </p>
<p>Exactly like <a class="el" href="vec_8h.html#a2619b3844488731f3361d09ad76ef855">cr8r_vec_resize</a> with self-&gt;len as the cap parameter </p><dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation, shouldn't happen unless ft-&gt;resize can fail to shrink) </dd></dl>

</div>
</div>
<a id="ac836b7eb6db947abf22dd5e69694814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac836b7eb6db947abf22dd5e69694814f">&#9670;&nbsp;</a></span>cr8r_vec_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from a vector. </p>
<p>Calls ft-&gt;del if applicable, and sets len to 0 </p>

</div>
</div>
<a id="aa4b6dcca4bdbc7caf7df8a78525c3ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b6dcca4bdbc7caf7df8a78525c3ef0">&#9670;&nbsp;</a></span>cr8r_vec_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the vector into a random permutation. </p>
<p>The algorithm produces permutations uniformly in theory, although in practice the number of permutations of a sufficiently large vector is enormously larger than the state space of any pseudorandom number generator. This won't cause any remotely meaningful patterns. </p>

</div>
</div>
<a id="aca7f424dd3f0a87649bf94995900b6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7f424dd3f0a87649bf94995900b6c8">&#9670;&nbsp;</a></span>cr8r_vec_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at a given index. </p>
<p>Similar to just doing self-&gt;buf + i*ft-&gt;base.size (recall that void pointer arithmetic acts like char pointer arithmetic), except that this function does bounds checking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element at index i, or NULL if i is out of bounds </dd></dl>

</div>
</div>
<a id="aabeda529e2562f99f42c1044e217cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeda529e2562f99f42c1044e217cc70">&#9670;&nbsp;</a></span>cr8r_vec_getx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_getx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at a given index, with support for negative indices. </p>
<p>Negative indicies work backwards, with -1 referring to the last element and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index to get, should be from 0 inclusive to self-&gt;len exclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element at index i, or NULL if i is out of bounds </dd></dl>

</div>
</div>
<a id="aa2aefad9c344d8c7d9a25b236d813312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aefad9c344d8c7d9a25b236d813312">&#9670;&nbsp;</a></span>cr8r_vec_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_vec_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a vector. </p>
<p>Simply returns self-&gt;len </p><dl class="section return"><dt>Returns</dt><dd>the length of the vector </dd></dl>

</div>
</div>
<a id="a136fc6242ac747df5f8bfa71bfd7e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136fc6242ac747df5f8bfa71bfd7e70d">&#9670;&nbsp;</a></span>cr8r_vec_pushr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_pushr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the right hand end of a vector. </p>
<p>Vectors are arranged with increasing indicies at increasing memory addresses, so this is an O(1) operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the element to add, which is copied from this pointer into the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a599c09159cb69c595de1aff43ee10b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599c09159cb69c595de1aff43ee10b83">&#9670;&nbsp;</a></span>cr8r_vec_popr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_popr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the right hand end of a vector. </p>
<p>Vectors are arranged with increasing indicies at increasing memory addresses, so this is an O(1) operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>the removed element is copied here from the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (ie if the vector was empty) </dd></dl>

</div>
</div>
<a id="ac26bf98f8cc996edc8a3fe5560cd6353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26bf98f8cc996edc8a3fe5560cd6353">&#9670;&nbsp;</a></span>cr8r_vec_pushl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_pushl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the left hand end of a vector. </p>
<p>This is an O(n) operation because vectors are arranged with increasing indicies at increasing memory addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>the element to add, which is copied from this pointer into the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ad1e46add615e3db6087de21050005522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e46add615e3db6087de21050005522">&#9670;&nbsp;</a></span>cr8r_vec_popl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_popl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the left hand end of a vector. </p>
<p>This is an O(n) operation because vectors are arranged with increasing indicies at increasing memory addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>the removed element is copied here from the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (ie if the vector was empty) </dd></dl>

</div>
</div>
<a id="a9dbf4d21bfe0ecf4236689abbcdd9692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbf4d21bfe0ecf4236689abbcdd9692">&#9670;&nbsp;</a></span>cr8r_vec_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a vector in-place. </p>
<p>ft-&gt;del is called on elements that fail the predicate, if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate to check elements with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation, shouldn't happen unless ft-&gt;resize can fail to shrink) </dd></dl>

</div>
</div>
<a id="a308fb59b1a449476504fa42ef604503b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308fb59b1a449476504fa42ef604503b">&#9670;&nbsp;</a></span>cr8r_vec_filtered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector as a subsequence matching a predicate. </p>
<p>Iterate over the elements of a vector and copy them into a new vector if they match the predicate. ft-&gt;copy function is called if applicable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>vector to fill with filtered subsequence, should have a cap of 0 or valid buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>vector to copy filtered sequence from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate to check elements with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a62e5fe3e3e68886fe5fc7c81cdd60951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e5fe3e3e68886fe5fc7c81cdd60951">&#9670;&nbsp;</a></span>cr8r_vec_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname"><em>src_ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname"><em>dest_ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *o, const void *e)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector by applying a transformation function to each element. </p>
<p>This creates a new vector, whose element type and entire function table may be different. The transformation funtion also must perform any relevant work that ft-&gt;copy would have to, since the output element type is not necessarily the same as the input element type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>vector to fill with outputs of transformation function, should have a cap of 0 or valid buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>vector of elements to pass to the transformation function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_ft</td><td>function table for src vector <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_ft</td><td>function table for dest vector <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>transformation function. The first argument, o, is a pointer to the element in the destination vector to output to, and the second argument, e, is a pointer to the element in the source vector to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="ad46c93576eec9e423ae336cec9e1fb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c93576eec9e423ae336cec9e1fb42">&#9670;&nbsp;</a></span>cr8r_vec_forEachPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_vec_forEachPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *, const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a function on every permutation of a vector. </p>
<p>The vector is actually permuted in place using Heap's algorithm, and ends at the "last" permutation without being restored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function. given the entire permuted vector and function table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (if an array of self-&gt;len uint64_t's cannot be allocated) </dd></dl>

</div>
</div>
<a id="a307ce32661ae90e4b3d5d751f9cea3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307ce32661ae90e4b3d5d751f9cea3ba">&#9670;&nbsp;</a></span>cr8r_vec_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new vector by concatenating copies of two given vectors. </p>
<p>First, ensures the dest buffer has enough capacity for both src vectors, extending if necessary, then copy the vectors one after the other. ft-&gt;copy is called if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>vector in which to store result, should have a cap of 0 or valid buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_a,src_b</td><td>vectors to copy elements from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="a5d51bc905d119424b59a57b6973041f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d51bc905d119424b59a57b6973041f5">&#9670;&nbsp;</a></span>cr8r_vec_augment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_augment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a copy of another vector to a given vector. </p>
<p>First, extends self-&gt;buf if needed, then copy the other vector right after the current end. ft-&gt;copy is called if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>vector to extend with a copy of the other vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>vector to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (allocation failure) </dd></dl>

</div>
</div>
<a id="ad8b8a19195b2639c4f526423272c07ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b8a19195b2639c4f526423272c07ad">&#9670;&nbsp;</a></span>cr8r_vec_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a predicate holds for all elements in a vector. </p>
<p>Returns false immediately if any element does not satisfy the predicate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on each element in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the predicate function returns 1 on all elements, 0 (as soon as it doesn't) otherwise </dd></dl>

</div>
</div>
<a id="a991f7bd28dd220d5d889354f8ba7f64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991f7bd28dd220d5d889354f8ba7f64b">&#9670;&nbsp;</a></span>cr8r_vec_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const void *)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a predicate holds for any element in a vector. </p>
<p>Returns true immediately if any element satisfies the predicate. Note that this is completely equivalent to the negation of <a class="el" href="vec_8h.html#ad8b8a19195b2639c4f526423272c07ad">cr8r_vec_all</a> with the negation of the predicate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate function, called on each element in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 (as soon as) the predicate function returns 1 on any element, 0 if it returns 0 on all of them </dd></dl>

</div>
</div>
<a id="a6c46fe63b3e84780b58260594e79a30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c46fe63b3e84780b58260594e79a30a">&#9670;&nbsp;</a></span>cr8r_vec_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a vector contains a given element. </p>
<p>This is O(n) because it does not assume a sorted vector and simply does a linear search. See <a class="el" href="">HC_VEC_containss</a> for a binary search version that does require a sorted vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the vector contains the element, 0 otherwise </dd></dl>

</div>
</div>
<a id="a3b32323f2ef92ca85694161725826e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b32323f2ef92ca85694161725826e97">&#9670;&nbsp;</a></span>cr8r_vec_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cr8r_vec_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first index of an element in a vector. </p>
<p>This is O(n) because it does not assume a sorted vector and simply does a linear search. See <a class="el" href="">HC_VEC_indexs</a> for a binary search version that does require a sorted vector. Returns -1 on failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the element if it is in the vector, or -1 otherwise </dd></dl>

</div>
</div>
<a id="a39842910c332246a6b58d89b7ce8aa52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39842910c332246a6b58d89b7ce8aa52">&#9670;&nbsp;</a></span>cr8r_vec_foldr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_foldr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *acc, const void *e)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a right fold on a vector. </p>
<p>Given an initial accumulator value of some type T in a void pointer, a vector, and a function that takes a void pointer to a T value and an element of the vector and returns a void pointer to a T value, this function repeatedly applies that function to the current accumulator value and vector element to get the new accumulator value. This is repeated for every element in the vector, going from left to right (low indices to high), and the final accumulator value is returned. The accumulation function must handle freeing old accumulator values once it is finished with them if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>starting value for the accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>accumulation function: should take current accumulator value (as void pointer) and current vector element and return new accumulator value. It should either modify the accumulator value in place, returning it as well, or allocate a new pointer for the new accumulator value and free the old one once the new one has been computed. In cases where the accumulator value is an integer or something else that fits within a pointer, the pointer can be used as a casted integer or whatnot instead of as a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final accumulator value </dd></dl>

</div>
</div>
<a id="a467b6a8b19b8ab8c55b2bb1abf855a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467b6a8b19b8ab8c55b2bb1abf855a0f">&#9670;&nbsp;</a></span>cr8r_vec_foldl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_vec_foldl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *acc, const void *e)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a left fold on a vector. </p>
<p>Exactly the same as <a class="el" href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">cr8r_vec_foldr</a> except vector entries are processed from right to left (high indices to low) instead of left to right (low to high). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>starting value for the accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>accumulation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final accumulator value </dd></dl>

</div>
</div>
<a id="a9bcbace693b2aa77a48b55291d74ad4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcbace693b2aa77a48b55291d74ad4f">&#9670;&nbsp;</a></span>cr8r_vec_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_vec_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a vector in-place according to ft-&gt;cmp. </p>
<p>Currently uses heapsort, so average and worst case time complexities are both O(n*log(n)). </p>

</div>
</div>
<a id="ae21dbfd3a9e07c60aeaade8c795e252c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21dbfd3a9e07c60aeaade8c795e252c">&#9670;&nbsp;</a></span>cr8r_vec_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sorted copy of a vector. </p>
<p>Simply calls <a class="el" href="vec_8h.html#adf7f642d154e92357ef970feb3e5c138">cr8r_vec_copy</a> followed by <a class="el" href="vec_8h.html#a9bcbace693b2aa77a48b55291d74ad4f">cr8r_vec_sort</a> on the copy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to copy to and sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="ae6f8d8acbaa9e05a05deb6173fb203ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f8d8acbaa9e05a05deb6173fb203ae">&#9670;&nbsp;</a></span>cr8r_vec_reversed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_reversed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a reversed copy of a vector. </p>
<p>copies elements in reverse order, using ft-&gt;copy if applicable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the vector to store the reversed copy in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the vector to create a reversed copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (memory allocation failure) </dd></dl>

</div>
</div>
<a id="aeee6e47feb7b49bf85b42d29acc41240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee6e47feb7b49bf85b42d29acc41240">&#9670;&nbsp;</a></span>cr8r_vec_containss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_vec_containss </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a sorted vector contains an element. </p>
<p>The vector should be in ascending order according to ft-&gt;cmp. Uses binary search, so the average and worst case time complexities are O(log(n)). If the elements are sorted and belong to some known distribution, some form of interpolation seach could work even faster, but this is best implemented as a custom function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the vector contains the element, 0 otherwise </dd></dl>

</div>
</div>
<a id="ae9591ba11330afa82d760d0ad111d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9591ba11330afa82d760d0ad111d410">&#9670;&nbsp;</a></span>cr8r_vec_indexs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cr8r_vec_indexs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of an element in a sorted vector. </p>
<p>The vector should be in ascending order according to ft-&gt;cmp. If there are multiple elements which compare equal to the query, the index of any one of them may be returned. Uses binary search, so the average and worst case time complexities are O(log(n)). If the elements are sorted and belong to some known distribution, some form of interpolation seach could work even faster, but this is best implemented as a custom function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>element to search for (using ft-&gt;cmp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the element in the vector, or -1 if not present </dd></dl>

</div>
</div>
<a id="ab4b70ed397697cecf35ff74c2f8a0b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b70ed397697cecf35ff74c2f8a0b7d">&#9670;&nbsp;</a></span>cr8r_vec_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cr8r_vec_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec.html">cr8r_vec</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcr8r__vec__ft.html">cr8r_vec_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographically compare two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>vectors to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if a is lexicographically before b, +1 visa versa, or 0 if they are equal </dd></dl>

</div>
</div>
<a id="a1184bc298656ebf85ea805949148bead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1184bc298656ebf85ea805949148bead">&#9670;&nbsp;</a></span>cr8r_default_acc_sum_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_acc_sum_u64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">cr8r_vec_foldr</a> to sum up elements in vector. </p>
<p>The first argument is treated as a uint64_t, NOT a pointer to uint64_t. Thus the call can be (uint64_t)cr8r_vec_foldr(self, ft, (void*)0, cr8r_default_acc_sum_u64). </p>

</div>
</div>
<a id="a188b2103e12f33772f020668bbc474ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188b2103e12f33772f020668bbc474ea">&#9670;&nbsp;</a></span>cr8r_default_acc_sumpowmod_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cr8r_default_acc_sumpowmod_u64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="vec_8h.html#a39842910c332246a6b58d89b7ce8aa52">cr8r_vec_foldr</a> to sum up powers of elements in a vector mod a number. </p>
<p>The first argument MUST be a pointer to three consecutive uint64_t's: the accumulator, the exponent, and the modulus, respectively. The same pointer is returned: the accumulator is modified in place. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
