<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/prand.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crater Container Library
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">prand.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="prand_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__prng.html">cr8r_prng</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PseudoRandom Number Generator.  <a href="structcr8r__prng.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae0a63ef9c19feae8110bc0474847d42f"><td class="memItemLeft" align="right" valign="top"><a id="ae0a63ef9c19feae8110bc0474847d42f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_N</b>&#160;&#160;&#160;312</td></tr>
<tr class="separator:ae0a63ef9c19feae8110bc0474847d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e24ec26989bdd9baf50d76cf620cd9e"><td class="memItemLeft" align="right" valign="top"><a id="a9e24ec26989bdd9baf50d76cf620cd9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_M</b>&#160;&#160;&#160;156</td></tr>
<tr class="separator:a9e24ec26989bdd9baf50d76cf620cd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a063308bf3a18adb8a22540355e95d"><td class="memItemLeft" align="right" valign="top"><a id="a86a063308bf3a18adb8a22540355e95d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_R</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a86a063308bf3a18adb8a22540355e95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb9345910648d04704b1ca32461bba"><td class="memItemLeft" align="right" valign="top"><a id="aa1eb9345910648d04704b1ca32461bba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_A</b>&#160;&#160;&#160;0xB5026F5AA96619E9</td></tr>
<tr class="separator:aa1eb9345910648d04704b1ca32461bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d43283bc88737027d0113babebda02"><td class="memItemLeft" align="right" valign="top"><a id="a97d43283bc88737027d0113babebda02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_U</b>&#160;&#160;&#160;29</td></tr>
<tr class="separator:a97d43283bc88737027d0113babebda02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ac696faa0cbb9227dbc1507b85ed1"><td class="memItemLeft" align="right" valign="top"><a id="a2f4ac696faa0cbb9227dbc1507b85ed1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_D</b>&#160;&#160;&#160;0x5555555555555555</td></tr>
<tr class="separator:a2f4ac696faa0cbb9227dbc1507b85ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f4d8beb0862fae7c4fffbd4e7fe28d"><td class="memItemLeft" align="right" valign="top"><a id="a96f4d8beb0862fae7c4fffbd4e7fe28d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_S</b>&#160;&#160;&#160;17</td></tr>
<tr class="separator:a96f4d8beb0862fae7c4fffbd4e7fe28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595f319c7b934de4fa45f464e33365a1"><td class="memItemLeft" align="right" valign="top"><a id="a595f319c7b934de4fa45f464e33365a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_B</b>&#160;&#160;&#160;0x71D67FFFEDA60000</td></tr>
<tr class="separator:a595f319c7b934de4fa45f464e33365a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f15433aba4bcc9568dab8636acc2e"><td class="memItemLeft" align="right" valign="top"><a id="ab51f15433aba4bcc9568dab8636acc2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_T</b>&#160;&#160;&#160;37</td></tr>
<tr class="separator:ab51f15433aba4bcc9568dab8636acc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27254fa8ac77294923dd55f816fb86"><td class="memItemLeft" align="right" valign="top"><a id="a0e27254fa8ac77294923dd55f816fb86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_C</b>&#160;&#160;&#160;0xFFF7EEE000000000</td></tr>
<tr class="separator:a0e27254fa8ac77294923dd55f816fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4512c8b0becedead44883316e9b236"><td class="memItemLeft" align="right" valign="top"><a id="aed4512c8b0becedead44883316e9b236"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_L</b>&#160;&#160;&#160;43</td></tr>
<tr class="separator:aed4512c8b0becedead44883316e9b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b8baf171f3b749ee0e2bdeba34fbd5"><td class="memItemLeft" align="right" valign="top"><a id="ad0b8baf171f3b749ee0e2bdeba34fbd5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_F</b>&#160;&#160;&#160;6364136223846793005</td></tr>
<tr class="separator:ad0b8baf171f3b749ee0e2bdeba34fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cd943590491468398f92590563efd51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a8cd943590491468398f92590563efd51">cr8r_prng_seed</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *, const char seed[*])</td></tr>
<tr class="memdesc:a8cd943590491468398f92590563efd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of a prng.  <a href="prand_8h.html#a8cd943590491468398f92590563efd51">More...</a><br /></td></tr>
<tr class="separator:a8cd943590491468398f92590563efd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a38a11e931811a1475c5c49202a8d4b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a7a38a11e931811a1475c5c49202a8d4b">cr8r_prng_get_u32</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:a7a38a11e931811a1475c5c49202a8d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single uint32_t from a prng.  <a href="prand_8h.html#a7a38a11e931811a1475c5c49202a8d4b">More...</a><br /></td></tr>
<tr class="separator:a7a38a11e931811a1475c5c49202a8d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f3191869f0095292da9a06975ef7f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a640f3191869f0095292da9a06975ef7f">cr8r_prng_get_u64</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:a640f3191869f0095292da9a06975ef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single uint64_t from a prng.  <a href="prand_8h.html#a640f3191869f0095292da9a06975ef7f">More...</a><br /></td></tr>
<tr class="separator:a640f3191869f0095292da9a06975ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877804d40fe3e0b5257145333d41a627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a877804d40fe3e0b5257145333d41a627">cr8r_prng_get_bytes</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *, uint64_t size, char buf[static size])</td></tr>
<tr class="memdesc:a877804d40fe3e0b5257145333d41a627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a buffer with random bytes from a prng.  <a href="prand_8h.html#a877804d40fe3e0b5257145333d41a627">More...</a><br /></td></tr>
<tr class="separator:a877804d40fe3e0b5257145333d41a627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45352623df6ef36bd0198da18fd4200"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ac45352623df6ef36bd0198da18fd4200">cr8r_prng_uniform_u64</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:ac45352623df6ef36bd0198da18fd4200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a uint64_t which is uniformly distributed on [a, b).  <a href="prand_8h.html#ac45352623df6ef36bd0198da18fd4200">More...</a><br /></td></tr>
<tr class="separator:ac45352623df6ef36bd0198da18fd4200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae0db179a04990f3ec47a1e29e986f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#acae0db179a04990f3ec47a1e29e986f0">cr8r_prng_init_system</a> ()</td></tr>
<tr class="memdesc:acae0db179a04990f3ec47a1e29e986f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on the system's prng device.  <a href="prand_8h.html#acae0db179a04990f3ec47a1e29e986f0">More...</a><br /></td></tr>
<tr class="separator:acae0db179a04990f3ec47a1e29e986f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbc4b86c3db859a68ff1f5883966643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#adcbc4b86c3db859a68ff1f5883966643">cr8r_prng_init_lcg</a> (uint64_t seed)</td></tr>
<tr class="memdesc:adcbc4b86c3db859a68ff1f5883966643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Linear Congruential Generator.  <a href="prand_8h.html#adcbc4b86c3db859a68ff1f5883966643">More...</a><br /></td></tr>
<tr class="separator:adcbc4b86c3db859a68ff1f5883966643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d20b436567d7a3c4a07128ab79353ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a4d20b436567d7a3c4a07128ab79353ea">cr8r_prng_init_lfg</a> (const char seed[static 6 *12+1])</td></tr>
<tr class="memdesc:a4d20b436567d7a3c4a07128ab79353ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Lagged Fibonacci Generator.  <a href="prand_8h.html#a4d20b436567d7a3c4a07128ab79353ea">More...</a><br /></td></tr>
<tr class="separator:a4d20b436567d7a3c4a07128ab79353ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39caeaee76bef3a59c3848a07bf9ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ad39caeaee76bef3a59c3848a07bf9ad8">cr8r_prng_init_mt</a> (uint64_t seed)</td></tr>
<tr class="memdesc:ad39caeaee76bef3a59c3848a07bf9ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Mersenne Twister Generator.  <a href="prand_8h.html#ad39caeaee76bef3a59c3848a07bf9ad8">More...</a><br /></td></tr>
<tr class="separator:ad39caeaee76bef3a59c3848a07bf9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1afaf8dd815ad1e0a51896b512904e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a9e1afaf8dd815ad1e0a51896b512904e">cr8r_prng_init_xoro</a> (const char seed[static 32])</td></tr>
<tr class="memdesc:a9e1afaf8dd815ad1e0a51896b512904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on Vigna and Blackman's Xoroshiro256** algorithm.  <a href="prand_8h.html#a9e1afaf8dd815ad1e0a51896b512904e">More...</a><br /></td></tr>
<tr class="separator:a9e1afaf8dd815ad1e0a51896b512904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6111faad151beef22c18ff5596f8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#aac6111faad151beef22c18ff5596f8da">cr8r_prng_xoro_jump_t128</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:aac6111faad151beef22c18ff5596f8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jump a xoro based prng forwards by 2**128 steps quickly.  <a href="prand_8h.html#aac6111faad151beef22c18ff5596f8da">More...</a><br /></td></tr>
<tr class="separator:aac6111faad151beef22c18ff5596f8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6578400630293828baecb190811f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a60f6578400630293828baecb190811f7">cr8r_prng_xoro_jump_t192</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:a60f6578400630293828baecb190811f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jump a xoro based prng forwards by 2**192 steps quickly.  <a href="prand_8h.html#a60f6578400630293828baecb190811f7">More...</a><br /></td></tr>
<tr class="separator:a60f6578400630293828baecb190811f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Comprehensive pseudorandom number generation interfaces.</p>
<p>PRNGs in general function by having an internal state (8-2496 bytes for the currently implemented generators), applying a function to the whole state, and then returning a part of the state (always 4 bytes for the generators implemented here). The function that transforms the state is not necessarily difficult to reverse or predict.</p>
<p>However, the entire state should be impossible to recover from less than state/4 outputs and difficult to recover from state_size/4 outputs. More importantly, the outputs should satisfy certain randomness tests, like producing bytes with equal frequency and so forth. Some of the most well known and widely used tests are the diehard tests, testU01, and the NIST tests.</p>
<p>PRNGs need to have their state initialized by "seeding". This can be done either by setting the entire state or by using a PRNG with smaller state to generate more state from a smaller initial state. For example, the Mersenne Twister has 2496 bytes of state but is usually initialized from 8 bytes using a Linear Congruential Generator. Whether the full state is needed or a smaller state is automatically expanded is specified in the documentation for the specific generator types. The quality of some PRNGs is more sensitive to the seed than that of others.</p>
<p>PRNGs generally have a finite period, meaning they eventually repeat. You can generally expect this to be around at most 2^B where B is the number of state bits. For instance, an LCG with modulus 2**64 has maximal period 2**62, the standard MT with 19968 bits of state has period 2**19967, and Xoroshiro256** with 256 bits of state has period 2**256 (maximal for any possible PRNG by the pidgeonhole principle).</p>
<p>You may wish to write a program that generates random numbers in multiple threads. Generally, Crater functions require you to do appropriate locking on your own, but for PRNGs the situation is more subtle. If using a single PRNG from multiple threads, it MUST be locked, unless it is known to be a "system" PRNG since then the state is maintained by the OS. However, locking is usually not ideal because it has significant overhead if you are generating a lot of random numbers. Therefore, use a different PRNG in each thread. HOWEVER, you should NOT simply use a different seed for each, as for some PRNG types this can cause increased correlation. Instead, the particular "jump" functions should be used to split up the output of the PRNG for a single seed. "jump" functions allow a PRNG to be advanced as if it were called a huge number of times very quickly. Currently, only 2 fixed size jump functions for Xoro are available, but more will be added soon.</p>
<p>Finally, some PRNGs are more suitable for cryptography and secure purporses than others. Generally this comes at the cost of speed. Only "system", the wrapper around Linux's getrandom syscall, should be considered secure. </p>

<p class="definition">Definition in file <a class="el" href="prand_8h_source.html">prand.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8cd943590491468398f92590563efd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd943590491468398f92590563efd51">&#9670;&nbsp;</a></span>cr8r_prng_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_prng_seed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>seed</em>[ *]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of a prng. </p>
<p>See the generator initialization functions for information on whether a single uint64_t or the entire state should be supplied, as well as what inputs are disallowed. </p><dl class="section return"><dt>Returns</dt><dd>true if the seed value is acceptable for the given generator, false otherwise </dd></dl>

</div>
</div>
<a id="a7a38a11e931811a1475c5c49202a8d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a38a11e931811a1475c5c49202a8d4b">&#9670;&nbsp;</a></span>cr8r_prng_get_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cr8r_prng_get_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single uint32_t from a prng. </p>
<p>Some prngs have a different natural output size than 32 bits, but all have been coerced into a size of 32 bits. This is because a lot of the time 32 bits is more than enough and 64 bits would require 2 calls for LCGs and LFGs, and MTs and Xoroshift can have problems with entropy in low bits anyway. </p>

</div>
</div>
<a id="a640f3191869f0095292da9a06975ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f3191869f0095292da9a06975ef7f">&#9670;&nbsp;</a></span>cr8r_prng_get_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_prng_get_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single uint64_t from a prng. </p>
<p>Always results in 2 calls to self-&gt;get_u32 in the current implementation </p>

</div>
</div>
<a id="a877804d40fe3e0b5257145333d41a627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877804d40fe3e0b5257145333d41a627">&#9670;&nbsp;</a></span>cr8r_prng_get_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_prng_get_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>buf</em>[static size]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a buffer with random bytes from a prng. </p>
<p>Gotten from ceil(size / 4) calls to self-&gt;get_u32 </p>

</div>
</div>
<a id="ac45352623df6ef36bd0198da18fd4200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45352623df6ef36bd0198da18fd4200">&#9670;&nbsp;</a></span>cr8r_prng_uniform_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_prng_uniform_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a uint64_t which is uniformly distributed on [a, b). </p>
<p>The output is not low-biased: if b - a &lt;= 1 &lt;&lt; 32, the generator is sampled 32 bits at a time until a result below the highest multiple of b - a &lt;= 1 &lt;&lt; 32 is obtained. This should always take less than 2 samples on average. If b - a &gt; 1 &lt;&lt; 32, the generator is sampled 64 bits at a time until a result below the highest multiple of b - a &lt;= 1 &lt;&lt; 64 is obtained. This should always take less than 4 32 bit samples on average. </p>

</div>
</div>
<a id="acae0db179a04990f3ec47a1e29e986f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae0db179a04990f3ec47a1e29e986f0">&#9670;&nbsp;</a></span>cr8r_prng_init_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on the system's prng device. </p>
<p>On Linux, this is based on "getrandom". The state size is 0 and attempts to seed generators of this type fail. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new system based prng (must be free'd), or NULL on failure (allocation/unsupported) </dd></dl>

</div>
</div>
<a id="adcbc4b86c3db859a68ff1f5883966643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbc4b86c3db859a68ff1f5883966643">&#9670;&nbsp;</a></span>cr8r_prng_init_lcg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_lcg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Linear Congruential Generator. </p>
<p>Seed value must not be 0! Seed value is a single uint64_t, on calls to <a class="el" href="prand_8h.html#a8cd943590491468398f92590563efd51">cr8r_prng_seed</a> it should be passed by address. LCGs are extremely fast and simple PRNGs that work by the rule x_n = a*x_(n-1) + c mod m. So if m is a power of 2 larger than 4 (ie 8 or higher), the maximal period is m/4 which is achieved for any a = 3 or 5 mod 8. The LCG parameters used are the same as muslc, namely a = 6364136223846793005, c = 1, and m = 2**64. Using any other values for m and c is unreasonable. The state is simply a 64 bit number, and the hi 32 bits are returned for each output. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new lcg based prng (must be free'd), or NULL on failure (allocation/seed == 0) ( <a class="el" href="prand_8h.html#a8cd943590491468398f92590563efd51">cr8r_prng_seed</a> will also fail if seed == 0 is passed) </dd></dl>

</div>
</div>
<a id="a4d20b436567d7a3c4a07128ab79353ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d20b436567d7a3c4a07128ab79353ea">&#9670;&nbsp;</a></span>cr8r_prng_init_lfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_lfg </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>seed</em>[static 6 *12+1]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Lagged Fibonacci Generator. </p>
<p>Seed value is used as a sequence of 12 48-bit integers followed by a single bit. At least one term in the seed sequence must be odd! In general, an LFG is defined by two "lookbacks" and a binary operation, so that x_n = x_[n-s] # x_[n-r] mod m for some binary operation #. This implementation uses the same parameters (namely s == 12, r == 5, m == 2**48, # == subtraction with carry) as the C++ standard library. The extra state/seed bit is the carry bit. In general, choosing good s nd r values is possible by considering irreducible polynomials of the form x^s + x^r + 1 mod 2 with s/r approaching the golden ratio. However, choosing the seed value is difficult and I could not find a good reference for it. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new lfg based prng (must be free'd), or NULL on failure (allocation/seed has no odd terms) ( <a class="el" href="prand_8h.html#a8cd943590491468398f92590563efd51">cr8r_prng_seed</a> will also fail if seed == 0 is passed) </dd></dl>

</div>
</div>
<a id="ad39caeaee76bef3a59c3848a07bf9ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39caeaee76bef3a59c3848a07bf9ad8">&#9670;&nbsp;</a></span>cr8r_prng_init_mt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_mt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Mersenne Twister Generator. </p>
<p>Seed value is a single uint64_t. If calling <a class="el" href="prand_8h.html#a8cd943590491468398f92590563efd51">cr8r_prng_seed</a> it should be passed by pointer. The state is 312 uint64_t's (2496 bytes), plus an additional index (1 more uint64_t or 8 more bytes). The full state is generated from the seed by a LCG. The parameters used here (including for the LCG) are the standard MT19937-64 generator configuration. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new MT based prng (must be free'd), or NULL on failure (allocation; currently all seed values are permitted) </dd></dl>

</div>
</div>
<a id="a9e1afaf8dd815ad1e0a51896b512904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1afaf8dd815ad1e0a51896b512904e">&#9670;&nbsp;</a></span>cr8r_prng_init_xoro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_xoro </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>seed</em>[static 32]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on Vigna and Blackman's Xoroshiro256** algorithm. </p>
<p>This PRNG seems to be very fast, closer to an LCG than a bulkier but more typical feedback shift register algorithm like MT, yet still have good properties on most tests. However, it has not been widely used for as long as MT. The seed/state is 32 bytes (4 uint64_t's) Also see <a class="el" href="prand_8h.html#aac6111faad151beef22c18ff5596f8da">cr8r_prng_xoro_jump_t128</a> and <a class="el" href="prand_8h.html#a60f6578400630293828baecb190811f7">cr8r_prng_xoro_jump_t192</a> </p><dl class="section return"><dt>Returns</dt><dd>pointer to new xoroshiro256** based prng (must be free'd), or NULL on failure (allocation; currently seed value is not quality checked) </dd></dl>

</div>
</div>
<a id="aac6111faad151beef22c18ff5596f8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6111faad151beef22c18ff5596f8da">&#9670;&nbsp;</a></span>cr8r_prng_xoro_jump_t128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_prng_xoro_jump_t128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jump a xoro based prng forwards by 2**128 steps quickly. </p>
<p>Do not call on non xoro prngs, it will scramble your memory. Remember the period of xoroshiro256** is 2**256. </p>

</div>
</div>
<a id="a60f6578400630293828baecb190811f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f6578400630293828baecb190811f7">&#9670;&nbsp;</a></span>cr8r_prng_xoro_jump_t192()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_prng_xoro_jump_t192 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jump a xoro based prng forwards by 2**192 steps quickly. </p>
<p>Do not call on non xoro prngs, it will scramble your memory. Remember the period of xoroshiro256** is 2**256. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
