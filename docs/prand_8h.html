<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crater Container Library: include/crater/prand.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Crater/index.html">Crater Container Library</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('prand_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">prand.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 Comprehensive pseudorandom number generation interfaces.</dd></dl>
<p>PRNGs in general function by having an internal state (8-2496 bytes for the currently implemented generators), applying a function to the whole state, and then returning a part of the state (always 4 bytes for the generators implemented here). The function that transforms the state is not necessarily difficult to reverse or predict.</p>
<p>However, the entire state should be impossible to recover from less than state/4 outputs and difficult to recover from state_size/4 outputs. More importantly, the outputs should satisfy certain randomness tests, like producing bytes with equal frequency and so forth. Some of the most well known and widely used tests are the diehard tests, testU01, and the NIST tests.</p>
<p>PRNGs need to have their state initialized by "seeding". This can be done either by setting the entire state or by using a PRNG with smaller state to generate more state from a smaller initial state. For example, the Mersenne Twister has 2496 bytes of state but is usually initialized from 8 bytes using a Linear Congruential Generator. The cr8r_prng_init_* functions use a uint32_t as a seed by default. This is generally sufficient, but keep in mind the disadantages and consider if setting the full state is required for your use case.</p>
<p>A prng's output sequence is a mathematical function of its state. Thus, when a prng is initialized from a 32 bit seed, there are only 2**32 possible output sequences (or fewer if the state has some restriction). This is usually a lot, but can skew probabilities in some cases. For example, for some prngs it is impossible to generate 0 as the first output if initial state is obtained by extending a 32 bit seed.</p>
<p>PRNGs generally have a finite period, meaning they eventually repeat. You can generally expect this to be around at most 2^B where B is the number of state bits. For instance, an LCG with modulus 2**64 has maximal period 2**62, the standard MT with 19968 bits of state has period 2**19967, and Xoroshiro256** with 256 bits of state has period 2**256 (maximal for any possible PRNG by the pidgeonhole principle).</p>
<p>You may wish to write a program that generates random numbers in multiple threads. Generally, Crater functions require you to do appropriate locking on your own, but for PRNGs the situation is more subtle. If using a single PRNG from multiple threads, it MUST be locked, unless it is known to be a "system" PRNG since then the state is maintained by the OS. However, locking is usually not ideal because it has significant overhead if you are generating a lot of random numbers. Therefore, use a different PRNG in each thread. HOWEVER, you should NOT simply use a different seed for each, as for some PRNG types this can cause increased correlation. Instead, the particular "jump" functions should be used to split up the output of the PRNG for a single seed. "jump" functions allow a PRNG to be advanced as if it were called a huge number of times very quickly. Currently, only 2 fixed size jump functions for Xoro are available, but more will be added soon.</p>
<p>The fact that randomized seeds are (usually, not as much for lcgs) worse than "jumping" to equidistant points in the output sequence may be very counterintuitive. It was for me at first. The reason is due to an even deeper peculiarity of prngs: namely, a maximal period prng goes through each STATE at most once per period by the pidgeonhole principle. But moreover, the k-tuples it produces are limited: for large enough k, it is mathematically impossible for it to produce every possible k-tuple. For example, if the state is 128 bytes, there are at most 2**1024 states. However, there are 2**1032 129-tuples of bytes, so it is impossible for such a prng to generate all such tuples. We want to generate all k-tuples for as large a k as possible without compromising randomness though. To achieve this, it is common for prngs to generate all k-tuples equally often for some k smaller than their state, For k == 1, this represents the simple fact that all bytes should be generated equally likely. True random bytes are equally distributed. And while true random k-tuples are equally likely, the probability of generating a fixed number of truly random k-tuples and getting perfectly equal amounts of all of them goes to zero very quickly. So in this sense the output of a prng can be very contrived, but this is necessary to make as many sequences as possible occur in the output.</p>
<p>Essentially, this is a tradeoff between "local" and "global" properties of the output sequence. An experement that requires random numbers cares about these local properties (is every sufficiently short byte sequence possible and equally likely, are outputs uncorrelated, etc), but not global properties (do all k-tuples occur exactly the same number of times). Put another way, you would expect the ratio of frequencies of any two k-tuples to approach 1 as you generated more and more random numbers, but you would expect the absolute difference to possibly be very large.</p>
<p>Finally, some PRNGs are more suitable for cryptography and secure purporses than others. Generally this comes at the cost of speed. Only "system", the wrapper around Linux's getrandom syscall, should be considered secure.</p>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>

<p class="definition">Definition in file <a class="el" href="prand_8h_source.html">prand.h</a>.</p>
</div>
<p><a href="prand_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcr8r__prng.html">cr8r_prng</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PseudoRandom Number Generator.  <a href="structcr8r__prng.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae0a63ef9c19feae8110bc0474847d42f"><td class="memItemLeft" align="right" valign="top"><a id="ae0a63ef9c19feae8110bc0474847d42f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_N</b>&#160;&#160;&#160;312</td></tr>
<tr class="separator:ae0a63ef9c19feae8110bc0474847d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e24ec26989bdd9baf50d76cf620cd9e"><td class="memItemLeft" align="right" valign="top"><a id="a9e24ec26989bdd9baf50d76cf620cd9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_M</b>&#160;&#160;&#160;156</td></tr>
<tr class="separator:a9e24ec26989bdd9baf50d76cf620cd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a063308bf3a18adb8a22540355e95d"><td class="memItemLeft" align="right" valign="top"><a id="a86a063308bf3a18adb8a22540355e95d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_R</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a86a063308bf3a18adb8a22540355e95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb9345910648d04704b1ca32461bba"><td class="memItemLeft" align="right" valign="top"><a id="aa1eb9345910648d04704b1ca32461bba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_A</b>&#160;&#160;&#160;0xB5026F5AA96619E9</td></tr>
<tr class="separator:aa1eb9345910648d04704b1ca32461bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d43283bc88737027d0113babebda02"><td class="memItemLeft" align="right" valign="top"><a id="a97d43283bc88737027d0113babebda02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_U</b>&#160;&#160;&#160;29</td></tr>
<tr class="separator:a97d43283bc88737027d0113babebda02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ac696faa0cbb9227dbc1507b85ed1"><td class="memItemLeft" align="right" valign="top"><a id="a2f4ac696faa0cbb9227dbc1507b85ed1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_D</b>&#160;&#160;&#160;0x5555555555555555</td></tr>
<tr class="separator:a2f4ac696faa0cbb9227dbc1507b85ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f4d8beb0862fae7c4fffbd4e7fe28d"><td class="memItemLeft" align="right" valign="top"><a id="a96f4d8beb0862fae7c4fffbd4e7fe28d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_S</b>&#160;&#160;&#160;17</td></tr>
<tr class="separator:a96f4d8beb0862fae7c4fffbd4e7fe28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595f319c7b934de4fa45f464e33365a1"><td class="memItemLeft" align="right" valign="top"><a id="a595f319c7b934de4fa45f464e33365a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_B</b>&#160;&#160;&#160;0x71D67FFFEDA60000</td></tr>
<tr class="separator:a595f319c7b934de4fa45f464e33365a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f15433aba4bcc9568dab8636acc2e"><td class="memItemLeft" align="right" valign="top"><a id="ab51f15433aba4bcc9568dab8636acc2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_T</b>&#160;&#160;&#160;37</td></tr>
<tr class="separator:ab51f15433aba4bcc9568dab8636acc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27254fa8ac77294923dd55f816fb86"><td class="memItemLeft" align="right" valign="top"><a id="a0e27254fa8ac77294923dd55f816fb86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_C</b>&#160;&#160;&#160;0xFFF7EEE000000000</td></tr>
<tr class="separator:a0e27254fa8ac77294923dd55f816fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4512c8b0becedead44883316e9b236"><td class="memItemLeft" align="right" valign="top"><a id="aed4512c8b0becedead44883316e9b236"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_L</b>&#160;&#160;&#160;43</td></tr>
<tr class="separator:aed4512c8b0becedead44883316e9b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b8baf171f3b749ee0e2bdeba34fbd5"><td class="memItemLeft" align="right" valign="top"><a id="ad0b8baf171f3b749ee0e2bdeba34fbd5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_MT_F</b>&#160;&#160;&#160;6364136223846793005</td></tr>
<tr class="separator:ad0b8baf171f3b749ee0e2bdeba34fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697bd74cf66c43d00cf8336d18aa371f"><td class="memItemLeft" align="right" valign="top"><a id="a697bd74cf66c43d00cf8336d18aa371f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_LFM_R</b>&#160;&#160;&#160;127</td></tr>
<tr class="separator:a697bd74cf66c43d00cf8336d18aa371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc8bc54884b864acc1daaf32009d434"><td class="memItemLeft" align="right" valign="top"><a id="a8bc8bc54884b864acc1daaf32009d434"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_PRNG_LFM_S</b>&#160;&#160;&#160;97</td></tr>
<tr class="separator:a8bc8bc54884b864acc1daaf32009d434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa673bed586c615993c4e56d44c15df"><td class="memItemLeft" align="right" valign="top"><a id="a0aa673bed586c615993c4e56d44c15df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_DEFAULT_PRNG_SM_SEED</b>&#160;&#160;&#160;0xd20499955ff0e57c</td></tr>
<tr class="separator:a0aa673bed586c615993c4e56d44c15df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30bbfdf3037017d7a166176218e3dda"><td class="memItemLeft" align="right" valign="top"><a id="ac30bbfdf3037017d7a166176218e3dda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR8R_DEFAULT_PRNG_LCG_SEED</b>&#160;&#160;&#160;0xe9352d1427990d8e</td></tr>
<tr class="separator:ac30bbfdf3037017d7a166176218e3dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad4596f7c54d9872920c2f57ccae72bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ad4596f7c54d9872920c2f57ccae72bc7">cr8r_prng_seed</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *, uint64_t)</td></tr>
<tr class="memdesc:ad4596f7c54d9872920c2f57ccae72bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of a prng.  <a href="prand_8h.html#ad4596f7c54d9872920c2f57ccae72bc7">More...</a><br /></td></tr>
<tr class="separator:ad4596f7c54d9872920c2f57ccae72bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a38a11e931811a1475c5c49202a8d4b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a7a38a11e931811a1475c5c49202a8d4b">cr8r_prng_get_u32</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:a7a38a11e931811a1475c5c49202a8d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single uint32_t from a prng.  <a href="prand_8h.html#a7a38a11e931811a1475c5c49202a8d4b">More...</a><br /></td></tr>
<tr class="separator:a7a38a11e931811a1475c5c49202a8d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f3191869f0095292da9a06975ef7f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a640f3191869f0095292da9a06975ef7f">cr8r_prng_get_u64</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:a640f3191869f0095292da9a06975ef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single uint64_t from a prng.  <a href="prand_8h.html#a640f3191869f0095292da9a06975ef7f">More...</a><br /></td></tr>
<tr class="separator:a640f3191869f0095292da9a06975ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbef6761d11dd124732c47d034e3e3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#afbef6761d11dd124732c47d034e3e3bd">cr8r_prng_get_bytes</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *, uint64_t size, void *buf)</td></tr>
<tr class="memdesc:afbef6761d11dd124732c47d034e3e3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a buffer with random bytes from a prng.  <a href="prand_8h.html#afbef6761d11dd124732c47d034e3e3bd">More...</a><br /></td></tr>
<tr class="separator:afbef6761d11dd124732c47d034e3e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45352623df6ef36bd0198da18fd4200"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ac45352623df6ef36bd0198da18fd4200">cr8r_prng_uniform_u64</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *, uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:ac45352623df6ef36bd0198da18fd4200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a uint64_t which is uniformly distributed on [a, b).  <a href="prand_8h.html#ac45352623df6ef36bd0198da18fd4200">More...</a><br /></td></tr>
<tr class="separator:ac45352623df6ef36bd0198da18fd4200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe1aadb2ff4641ea385d0578309c52"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ae7fe1aadb2ff4641ea385d0578309c52">cr8r_prng_uniform01_double</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:ae7fe1aadb2ff4641ea385d0578309c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double which is uniformly distributed on [0, 1)  <a href="prand_8h.html#ae7fe1aadb2ff4641ea385d0578309c52">More...</a><br /></td></tr>
<tr class="separator:ae7fe1aadb2ff4641ea385d0578309c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93412d1b22265782ceaaa41ce9404948"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a93412d1b22265782ceaaa41ce9404948">cr8r_prng_log_mod_t64</a> (uint64_t h)</td></tr>
<tr class="memdesc:a93412d1b22265782ceaaa41ce9404948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find x (the discrete logarithm) so that h = g**x mod 2**64.  <a href="prand_8h.html#a93412d1b22265782ceaaa41ce9404948">More...</a><br /></td></tr>
<tr class="separator:a93412d1b22265782ceaaa41ce9404948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae0db179a04990f3ec47a1e29e986f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#acae0db179a04990f3ec47a1e29e986f0">cr8r_prng_init_system</a> ()</td></tr>
<tr class="memdesc:acae0db179a04990f3ec47a1e29e986f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on the system's prng device.  <a href="prand_8h.html#acae0db179a04990f3ec47a1e29e986f0">More...</a><br /></td></tr>
<tr class="separator:acae0db179a04990f3ec47a1e29e986f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbc4b86c3db859a68ff1f5883966643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#adcbc4b86c3db859a68ff1f5883966643">cr8r_prng_init_lcg</a> (uint64_t seed)</td></tr>
<tr class="memdesc:adcbc4b86c3db859a68ff1f5883966643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Linear Congruential Generator.  <a href="prand_8h.html#adcbc4b86c3db859a68ff1f5883966643">More...</a><br /></td></tr>
<tr class="separator:adcbc4b86c3db859a68ff1f5883966643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59593ec213c0a258e487689a6551c1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ac59593ec213c0a258e487689a6551c1d">cr8r_prng_init_lfg_sc</a> (uint64_t seed)</td></tr>
<tr class="memdesc:ac59593ec213c0a258e487689a6551c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Subtract with Carry Lagged Fibonacci Generator.  <a href="prand_8h.html#ac59593ec213c0a258e487689a6551c1d">More...</a><br /></td></tr>
<tr class="separator:ac59593ec213c0a258e487689a6551c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78392309413c5be1f05b316c52da8219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a78392309413c5be1f05b316c52da8219">cr8r_prng_init_lfg_m</a> (uint64_t seed)</td></tr>
<tr class="memdesc:a78392309413c5be1f05b316c52da8219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Multiplication Lagged Fibonnacci Generator.  <a href="prand_8h.html#a78392309413c5be1f05b316c52da8219">More...</a><br /></td></tr>
<tr class="separator:a78392309413c5be1f05b316c52da8219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39caeaee76bef3a59c3848a07bf9ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ad39caeaee76bef3a59c3848a07bf9ad8">cr8r_prng_init_mt</a> (uint64_t seed)</td></tr>
<tr class="memdesc:ad39caeaee76bef3a59c3848a07bf9ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on a Mersenne Twister Generator.  <a href="prand_8h.html#ad39caeaee76bef3a59c3848a07bf9ad8">More...</a><br /></td></tr>
<tr class="separator:ad39caeaee76bef3a59c3848a07bf9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814a4e6c3c4bd37a99f7262c622dfe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#ae814a4e6c3c4bd37a99f7262c622dfe3">cr8r_prng_init_xoro</a> (uint64_t seed)</td></tr>
<tr class="memdesc:ae814a4e6c3c4bd37a99f7262c622dfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on Vigna and Blackman's Xoroshiro256** algorithm.  <a href="prand_8h.html#ae814a4e6c3c4bd37a99f7262c622dfe3">More...</a><br /></td></tr>
<tr class="separator:ae814a4e6c3c4bd37a99f7262c622dfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddb37ca49e0102188bdbf2e6b11dfa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a6ddb37ca49e0102188bdbf2e6b11dfa5">cr8r_prng_init_splitmix</a> (uint64_t seed)</td></tr>
<tr class="memdesc:a6ddb37ca49e0102188bdbf2e6b11dfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PRNG based on Vigna's version of SplitMix.  <a href="prand_8h.html#a6ddb37ca49e0102188bdbf2e6b11dfa5">More...</a><br /></td></tr>
<tr class="separator:a6ddb37ca49e0102188bdbf2e6b11dfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6111faad151beef22c18ff5596f8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#aac6111faad151beef22c18ff5596f8da">cr8r_prng_xoro_jump_t128</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:aac6111faad151beef22c18ff5596f8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jump a xoro based prng forwards by 2**128 steps quickly.  <a href="prand_8h.html#aac6111faad151beef22c18ff5596f8da">More...</a><br /></td></tr>
<tr class="separator:aac6111faad151beef22c18ff5596f8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6578400630293828baecb190811f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a60f6578400630293828baecb190811f7">cr8r_prng_xoro_jump_t192</a> (<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *)</td></tr>
<tr class="memdesc:a60f6578400630293828baecb190811f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jump a xoro based prng forwards by 2**192 steps quickly.  <a href="prand_8h.html#a60f6578400630293828baecb190811f7">More...</a><br /></td></tr>
<tr class="separator:a60f6578400630293828baecb190811f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3653a4604d358edaa1d82e941a0e3d94"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a3653a4604d358edaa1d82e941a0e3d94">cr8r_prng_2tg_t64</a> [4]</td></tr>
<tr class="memdesc:a3653a4604d358edaa1d82e941a0e3d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multipliers for 3**x in the result of <a class="el" href="prand_8h.html#a93412d1b22265782ceaaa41ce9404948">cr8r_prng_log_mod_t64</a> This is the Klein 4 group embedded in the multiplicative group mod 2**64, or equivalently the 2-Torsion Group mod 2**64.  <a href="prand_8h.html#a3653a4604d358edaa1d82e941a0e3d94">More...</a><br /></td></tr>
<tr class="separator:a3653a4604d358edaa1d82e941a0e3d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0809010c1f86d7834baa6bdb4db71b1d"><td class="memItemLeft" align="right" valign="top"><a id="a0809010c1f86d7834baa6bdb4db71b1d"></a>
<a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="prand_8h.html#a0809010c1f86d7834baa6bdb4db71b1d">cr8r_default_prng_splitmix</a></td></tr>
<tr class="memdesc:a0809010c1f86d7834baa6bdb4db71b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default SplitMix prng, automatically used to extend seed values to state values if needed. <br /></td></tr>
<tr class="separator:a0809010c1f86d7834baa6bdb4db71b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad4596f7c54d9872920c2f57ccae72bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4596f7c54d9872920c2f57ccae72bc7">&#9670;&nbsp;</a></span>cr8r_prng_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cr8r_prng_seed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of a prng. </p>
<p>WARNING: accesses <a class="el" href="prand_8h.html#a0809010c1f86d7834baa6bdb4db71b1d">cr8r_default_prng_splitmix</a> for generators where state_size &gt; sizeof(uint64_t), all accesses to the default splitmix prng should be done in the same thread or protected by locks. If necessary, the given seed is extended using splitmix to generate random bytes according to prng-&gt;state_size, and then prng-&gt;fixup_state is called. Returns false only if fixup_state fails. </p>

</div>
</div>
<a id="a7a38a11e931811a1475c5c49202a8d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a38a11e931811a1475c5c49202a8d4b">&#9670;&nbsp;</a></span>cr8r_prng_get_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cr8r_prng_get_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single uint32_t from a prng. </p>
<p>Some prngs have a different natural output size than 32 bits, but all have been coerced into a size of 32 bits. This is because a lot of the time 32 bits is more than enough and 64 bits would require 2 calls for LCGs and LFGs, and MTs and Xoroshift can have problems with entropy in low bits anyway. </p>

</div>
</div>
<a id="a640f3191869f0095292da9a06975ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f3191869f0095292da9a06975ef7f">&#9670;&nbsp;</a></span>cr8r_prng_get_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_prng_get_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single uint64_t from a prng. </p>
<p>Always results in 2 calls to self-&gt;get_u32 in the current implementation </p>

</div>
</div>
<a id="afbef6761d11dd124732c47d034e3e3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbef6761d11dd124732c47d034e3e3bd">&#9670;&nbsp;</a></span>cr8r_prng_get_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_prng_get_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a buffer with random bytes from a prng. </p>
<p>Gotten from ceil(size / 4) calls to self-&gt;get_u32 </p>

</div>
</div>
<a id="ac45352623df6ef36bd0198da18fd4200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45352623df6ef36bd0198da18fd4200">&#9670;&nbsp;</a></span>cr8r_prng_uniform_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_prng_uniform_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a uint64_t which is uniformly distributed on [a, b). </p>
<p>The output is not low-biased: if b - a &lt;= 1 &lt;&lt; 32, the generator is sampled 32 bits at a time until a result below the highest multiple of b - a &lt;= 1 &lt;&lt; 32 is obtained. This should always take less than 2 samples on average. If b - a &gt; 1 &lt;&lt; 32, the generator is sampled 64 bits at a time until a result below the highest multiple of b - a &lt;= 1 &lt;&lt; 64 is obtained. This should always take less than 4 32 bit samples on average. </p>

</div>
</div>
<a id="ae7fe1aadb2ff4641ea385d0578309c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe1aadb2ff4641ea385d0578309c52">&#9670;&nbsp;</a></span>cr8r_prng_uniform01_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cr8r_prng_uniform01_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a double which is uniformly distributed on [0, 1) </p>
<p>Does not include denormalized numbers, only normal format doubles from 0 inclusive to 1 exclusive. </p>

</div>
</div>
<a id="a93412d1b22265782ceaaa41ce9404948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93412d1b22265782ceaaa41ce9404948">&#9670;&nbsp;</a></span>cr8r_prng_log_mod_t64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cr8r_prng_log_mod_t64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find x (the discrete logarithm) so that h = g**x mod 2**64. </p>
<p>This is a key step in "jumping" multiplicative lagged Fibonacci generators because it allows us to rewrite x_i = x_(i-s) * x_(i-r) mod 2**k by expressing x_i as g**(a_i mod 2**(k-2)).</p>
<p>At least, it would let us do this, but discrete logarithm modulo powers of 2 works differently than discrete logarithm modulo powers of odd primes. A generator for the multiplicative group only exists mod 2, 4, p**k, and 2*p**k where p is any odd prime. In particular, the multiplicative group modulo 2**k does not have a generator for k &gt; 2 and instead decomposes as the direct product of the group with 2 elements and the cyclic group mod 2**(k-2). The multiplicative group mod 8, aka the klein 4 group, has 4 elements: 1, 3, 5, and 7 and is always embedded in the multiplicative group. It is more convenient to use the representation 1, 2**(k-1)-1, 2**(k-1)+1, -1.</p>
<p>Therefore, we can express each x_i as g**(a_i)*p**(b_i)*q**(c_i) where p and q represent the generators of the klein 4 group, namely 2**(k-1)-1 and 2**(k-1)+1. This turns the difficult to understand recurrence x_i = x_(i-s)*s_(i-r) mod 2**k into three separate linear recurrences which are easy to understand, namely a_i = a_(i-s) + a_(i-r) mod 2**(k-2), the same for b mod 2, and the same for c mod 2.</p>
<p>h must be odd or the result will be garbage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>power of g to find the exponent of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>base of logarithm. because the multiplicative group of 2**64 is not cyclic, g can be +/-3 or 2**63 +/- 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>discrete logarithm x so that h = 3**x*p**a*q**b mod 2**64. The low 62 bits are x. The highest bit indicates a and the second highest indicates b. Recall that p = 2**63-1 and q = 2**63+1. You can get p**a*q**b via <code>cr8r_prng_2tg_t64[res &gt;&gt; 62]</code>. On failure, 0 is returned, which should only happen if h is even, but still, check if 0 is returned and h is not 1. </dd></dl>

</div>
</div>
<a id="acae0db179a04990f3ec47a1e29e986f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae0db179a04990f3ec47a1e29e986f0">&#9670;&nbsp;</a></span>cr8r_prng_init_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on the system's prng device. </p>
<p>On Linux, this is based on "getrandom". The state size is 0 and attempts to seed generators of this type fail. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new system based prng (must be free'd), or NULL on failure (allocation/unsupported) </dd></dl>

</div>
</div>
<a id="adcbc4b86c3db859a68ff1f5883966643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbc4b86c3db859a68ff1f5883966643">&#9670;&nbsp;</a></span>cr8r_prng_init_lcg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_lcg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Linear Congruential Generator. </p>
<p>Seed value must not be 0! Seed value is a single uint64_t, on calls to <a class="el" href="prand_8h.html#ad4596f7c54d9872920c2f57ccae72bc7">cr8r_prng_seed</a> it should be passed by address. LCGs are extremely fast and simple PRNGs that work by the rule x_n = a*x_(n-1) + c mod m. So if m is a power of 2 larger than 4 (ie 8 or higher), the maximal period is m/4 which is achieved for any a = 3 or 5 mod 8. The LCG parameters used are the same as muslc, namely a = 6364136223846793005, c = 1, and m = 2**64. Using any other values for m and c is unreasonable. The state is simply a 64 bit number, and the hi 32 bits are returned for each output. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new lcg based prng (must be free'd), or NULL on failure (allocation/seed == 0) ( <a class="el" href="prand_8h.html#ad4596f7c54d9872920c2f57ccae72bc7">cr8r_prng_seed</a> will also fail if seed == 0 is passed) </dd></dl>

</div>
</div>
<a id="ac59593ec213c0a258e487689a6551c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59593ec213c0a258e487689a6551c1d">&#9670;&nbsp;</a></span>cr8r_prng_init_lfg_sc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_lfg_sc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Subtract with Carry Lagged Fibonacci Generator. </p>
<p>WARNING: accesses <a class="el" href="prand_8h.html#a0809010c1f86d7834baa6bdb4db71b1d">cr8r_default_prng_splitmix</a>, all accesses to the default splitmix prng should be done in the same thread or protected by locks. In general, an LFG is defined by two "lookbacks" and a binary operation, so that x_n = x_[n-s] # x_[n-r] mod m for some binary operation #. This implementation uses the same parameters (namely s == 12, r == 5, m == 2**48, # == subtraction with carry) as the C++ standard library. The extra state/seed bit is the carry bit. In general, choosing good s nd r values is possible by considering irreducible polynomials of the form x^s + x^r + 1 mod 2 with s/r approaching the golden ratio. However, choosing the seed value is difficult and I could not find a good reference for it. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new lfg based prng (must be free'd), or NULL on failure (allocation failure; fixup_state should not fail) </dd></dl>

</div>
</div>
<a id="a78392309413c5be1f05b316c52da8219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78392309413c5be1f05b316c52da8219">&#9670;&nbsp;</a></span>cr8r_prng_init_lfg_m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_lfg_m </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Multiplication Lagged Fibonnacci Generator. </p>
<p>WARNING: accesses <a class="el" href="prand_8h.html#a0809010c1f86d7834baa6bdb4db71b1d">cr8r_default_prng_splitmix</a>, all accesses to the default splitmix prng should be done in the same thread or protected by locks. This should produce higher quality random numbers than the subtract with carry approach (measured by ising model simulation). It also does not need an extra carry bit in the state. The considerations when picking such a generator are almost exactly the same as when picking an additive LFG such as subtract with carry, except that all terms in the seed sequence must be odd and the linear recurrence is in the exponents rather than the values directly. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new lfg based prng (must be free'd), or NULL on failure (allocation failure; fixup_state should not fail) </dd></dl>

</div>
</div>
<a id="ad39caeaee76bef3a59c3848a07bf9ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39caeaee76bef3a59c3848a07bf9ad8">&#9670;&nbsp;</a></span>cr8r_prng_init_mt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_mt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on a Mersenne Twister Generator. </p>
<p>Seed value is a single uint64_t. If calling <a class="el" href="prand_8h.html#ad4596f7c54d9872920c2f57ccae72bc7">cr8r_prng_seed</a> it should be passed by pointer. The state is 312 uint64_t's (2496 bytes), plus an additional index (1 more uint64_t or 8 more bytes). The full state is generated from the seed by a LCG. The parameters used here (including for the LCG) are the standard MT19937-64 generator configuration. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new MT based prng (must be free'd), or NULL on failure (allocation; currently all seed values are permitted) </dd></dl>

</div>
</div>
<a id="ae814a4e6c3c4bd37a99f7262c622dfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814a4e6c3c4bd37a99f7262c622dfe3">&#9670;&nbsp;</a></span>cr8r_prng_init_xoro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_xoro </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on Vigna and Blackman's Xoroshiro256** algorithm. </p>
<p>WARNING: accesses <a class="el" href="prand_8h.html#a0809010c1f86d7834baa6bdb4db71b1d">cr8r_default_prng_splitmix</a>, all accesses to the default splitmix prng should be done in the same thread or protected by locks. This PRNG seems to be very fast, closer to an LCG than a bulkier but more typical feedback shift register algorithm like MT, yet still have good properties on most tests. However, it has not been widely used for as long as MT. The seed/state is 32 bytes (4 uint64_t's) Also see <a class="el" href="prand_8h.html#aac6111faad151beef22c18ff5596f8da">cr8r_prng_xoro_jump_t128</a> and <a class="el" href="prand_8h.html#a60f6578400630293828baecb190811f7">cr8r_prng_xoro_jump_t192</a> </p><dl class="section return"><dt>Returns</dt><dd>pointer to new xoroshiro256** based prng (must be free'd), or NULL on failure (allocation; algorithm is seed-agnostic) </dd></dl>

</div>
</div>
<a id="a6ddb37ca49e0102188bdbf2e6b11dfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddb37ca49e0102188bdbf2e6b11dfa5">&#9670;&nbsp;</a></span>cr8r_prng_init_splitmix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcr8r__prng.html">cr8r_prng</a>* cr8r_prng_init_splitmix </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PRNG based on Vigna's version of SplitMix. </p>
<p>SplitMix is a light hash applied to a counter. This algorithm passes all testU01 tests, however, it is mostly included to initialize the other PRNGS. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new splitmix based prng (must be free'd), or NULL on failure (allocation failure; algorithm is seed-agnostic) </dd></dl>

</div>
</div>
<a id="aac6111faad151beef22c18ff5596f8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6111faad151beef22c18ff5596f8da">&#9670;&nbsp;</a></span>cr8r_prng_xoro_jump_t128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_prng_xoro_jump_t128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jump a xoro based prng forwards by 2**128 steps quickly. </p>
<p>Do not call on non xoro prngs, it will scramble your memory. Remember the period of xoroshiro256** is 2**256. </p>

</div>
</div>
<a id="a60f6578400630293828baecb190811f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f6578400630293828baecb190811f7">&#9670;&nbsp;</a></span>cr8r_prng_xoro_jump_t192()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cr8r_prng_xoro_jump_t192 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcr8r__prng.html">cr8r_prng</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jump a xoro based prng forwards by 2**192 steps quickly. </p>
<p>Do not call on non xoro prngs, it will scramble your memory. Remember the period of xoroshiro256** is 2**256. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3653a4604d358edaa1d82e941a0e3d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3653a4604d358edaa1d82e941a0e3d94">&#9670;&nbsp;</a></span>cr8r_prng_2tg_t64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t cr8r_prng_2tg_t64[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The multipliers for 3**x in the result of <a class="el" href="prand_8h.html#a93412d1b22265782ceaaa41ce9404948">cr8r_prng_log_mod_t64</a> This is the Klein 4 group embedded in the multiplicative group mod 2**64, or equivalently the 2-Torsion Group mod 2**64. </p>
<p>All odd numbers mod 2**64 decompose as c*3**x where c is in this array. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27aea823fd5451555362d8413ef076c0.html">crater</a></li><li class="navelem"><a class="el" href="prand_8h.html">prand.h</a></li>
    <li class="footer">Generated on Tue Feb 13 2024 04:57:27 for Crater Container Library by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
